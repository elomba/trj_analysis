module mod_clusters
   use mod_precision
   use mod_common
   use mod_input
   use mod_sq
   use mod_rdf
   use mod_densprof
   use mod_thermo
   use cudafor
   use mod_nc_conf, only : conf, wtypes, natoms, imol
   implicit none
   integer :: io_centers_file, io_clusevol_file, io_shape_file, nmaxcl
   character(len=17) :: centers_filename = 'centers.lammpstrj'
   character(len=12) :: clusevol_filename = 'clusevol.dat'
   character(len=10) :: fshape_filename = 'fshape.dat'
   Real(myprec), allocatable :: clmfracav(:), dsph(:), dratio(:), countcl(:)
   Real(myprec), allocatable :: cluster_order_cos(:,:), cluster_order_sin(:,:), cluster_ql(:,:), &
      avcluster_order_cos(:), avcluster_order_sin(:), avcluster_order(:)
   interface
      function minj(dim, members, nm, center, sidel, side2)
         use mod_precision
         integer, intent(IN) :: nm, dim
         integer, intent(IN) :: members(nm)
         real, intent(IN) :: center(3), sidel(3), side2
      end function minj

      function cldens(dim, members, nm, sidel, side2, center, rclus)
         use mod_precision
         integer, intent(IN) :: nm, dim
         integer, intent(IN) :: members(nm)
         real, intent(IN) :: sidel(3), side2, center(3), rclus
         real :: avcldens
      end function cldens

      function radius(members, nm, center, sidel)
         use mod_precision
         integer, intent(IN) :: nm
         integer, intent(IN) :: members(nm)
         real(myprec), intent(IN) :: center(3), sidel(3)
      end function radius

      function radiusRg(members, nm, center, sidel, masat)
         use mod_precision
         integer, intent(IN) :: nm
         integer, intent(IN) :: members(nm)
         real(myprec), intent(IN) :: center(3), sidel(3), masat
      end function radiusRg
   end interface
contains

   subroutine cluster_analysis(Iconf)
      !
      ! Compute cluster properties
      !
      implicit none
      integer, intent(IN) :: Iconf
      integer :: i, j, k, cluster_id, icl, ip, ind, indr, maxcl,&
      & imaxcl, clsz, clussize, cmin, NP_lconf, icount, im, countlarge
      Real(myprec), Dimension(3) ::  c0, rv, rv2, rvi, rvj, desp, xi, si, xss, sss, theta, clcent, vcl
      Real(myprec) :: denscl, rmcl, cdmax=0
      Real(myprec), allocatable, save :: molfrac(:), clmfrac(:)
      Real(kind=8) ::  mcl, ekcls, suma, rclus, rcluster, rgsum, averg, volcl, factorv=1.0
      if (conf(4)%units == 'femtosecond' ) factorv = 0.001
      if (maxcln < 1) maxcln = 1 
      if (Iconf > 1) then
         deallocate (cluster, contador)
         if (run_order) then
            deallocate(cluster_order_cos)
            deallocate(cluster_order_sin)
            deallocate(cluster_ql)
         end if
         if (run_thermo) then
            deallocate(bigcl_d)
            deallocate(engcls,bigcl)
         endif
      else
         allocate(clusid(1:nmol))
         allocate(clusid_d(1:nmol))
         allocate(molfrac(1:nsp), clmfrac(1:nsp), clmfracav(1:nsp))
         clmfracav(1:nsp) = 0.0
         clmfrac(:) = 0.0
         molfrac(:) = 0.0
         if (run_order) then
            allocate(avcluster_order_cos(norder))
            allocate(avcluster_order_sin(norder))
            allocate(avcluster_order(norder))
            avcluster_order_cos(:) = 0.0
            avcluster_order_sin(:) = 0.0
            avcluster_order(:) = 0.0
         end if 
      end if
      allocate (cluster(maxcln), contador(maxcln))
      if (run_thermo) then
         allocate(bigcl_d(maxcln))
         allocate(engcls(maxcln),bigcl(maxcln))
      endif
      if (run_order) then
         allocate(cluster_order_cos(maxcln, norder))
         allocate(cluster_order_sin(maxcln, norder))
         allocate(cluster_ql(maxcln, norder))
         cluster_order_cos(:,:) = 0.0
         cluster_order_sin(:,:) = 0.0
         cluster_ql(:,:) = 0.0
      end if
      Cluster_id = maxcln
      contador(:) = 0
      maxcl = 0
      do i = 1, cluster_id

         clsz = count(done == i)
         if (clsz > maxcl) then
            maxcl = clsz
            imaxcl = i
         end if
         cluster(i)%clsize = clsz
         allocate (cluster(i)%members(clsz))
         allocate (cluster(i)%molfrac(nsp))
         !
      end do
      contador(:) = 0
      do i = 1, Nmol
         j = done(i)
         if (j > 0) then
            contador(j) = contador(j) + 1
            cluster(j)%members(contador(j)) = i
         end if
      end do
      clusid(:) = 0
      do i = 1, cluster_id
         ! identify to which cluster belongs each particle
         do j = 1, cluster(i)%clsize
            clusid(cluster(i)%members(j)) = I
         end do
      end do
      clusid_d(1:nmol) = clusid(1:nmol)
      !
      ! Write trajectory file with centers of mass of clusters 
      !
      write (io_centers_file, "('ITEM: TIMESTEP'/I12/'ITEM: NUMBER OF ATOMS'/I12/'ITE&
      &M: BOX BOUNDS pp pp pp')") nstep, maxcln
      write (io_centers_file, "(2f15.7)") (0.0, sidel(i), i=1, ndim)
      if (ndim == 2) write (io_centers_file, "('-0.5 0.5')")
      if (ex_vel) then
         write (io_centers_file, "('ITEM: ATOMS id type x y z vx vy vz')")
      else
         write (io_centers_file, "('ITEM: ATOMS id type x y z')")
      end if
      icl = 0
      cluster(:)%rg = 0
      if (Iconf == Nconf) NP_lconf = 0
      do I = 1, cluster_id
         j = cluster(i)%clsize
         ! Calculate cluster size distro
         ind = nint(real(j)/real(dcl))
         sizedist(ind) = sizedist(ind) + 1
         ! Determine center of mass with PBC
         ! https://en.wikipedia.org/wiki/Center_of_mass#Systems_with_periodic_boundary_conditions
         xss(:) = 0
         sss(:) = 0
         vcl(:) = 0
         mcl = 0
         ekcls = 0
         rgsum = 0.0
         do k = 1, j
               ip = cluster(i)%members(k)
               rv(1:ndim) = r(1:ndim, ip)
               theta(1:ndim) = 2*pi*rv(1:ndim)/sidelv(1:ndim)
               xss(1:ndim) = xss(1:ndim) + cos(theta(1:ndim))
               sss(1:ndim) = sss(1:ndim) + sin(theta(1:ndim))
               vcl(1:ndim) = vcl(1:ndim) + masa(ip)*vel(1:ndim, ip)
               mcl = mcl + masa(ip)
         end do
         xss(1:ndim) = xss(1:ndim)/j
         sss(1:ndim) = sss(1:ndim)/j
         theta(1:ndim) = atan2(-sss(1:ndim), -xss(1:ndim)) + pi
         !
         ! Restore origin for geometric centers  position to the original coordinate
         !
         cluster(i)%center(1:ndim) = sidelv(1:ndim)*theta(1:ndim)/(2*pi) + rlow(1:ndim)
         !
         ! Store cluster's center of mass velocity and net mass
         !
         cluster(i)%vl(1:ndim) = vcl(1:ndim)/mcl
         cluster(i)%mass = mcl
         ekcls = 0
         do k = 1, j
               ip = cluster(i)%members(k)
               ekcls = ekcls + 0.5*masa(ip)*dot_product(vel(:, ip)&
               &- cluster(i)%vl(:), vel(:, ip) - cluster(i)%vl(:))
         end do
         cluster(i)%ekin = ekcls
         if (ex_vel) then
               if (ndim == 3) then
                  write (io_centers_file, '(2i10,6f15.7)') i, 1, cluster(i)%center(1:ndim), factorv*cluster(i)%vl(1:ndim)
               else
                  write (io_centers_file, '(2i10,6f15.7)') i, 1, cluster(i)%center(1:ndim), 0.0,factorv*cluster(i)%vl(1:ndim),0.0
               end if
         else
               if (ndim == 3) then
                  write (io_centers_file, '(2i10,6f15.7)') i, 1, cluster(i)%center(1:ndim)
               else
                  write (io_centers_file, '(2i10,6f15.7)') i, 1, cluster(i)%center(1:ndim), 0.0
               end if
            endif
         if (Iconf == Nconf) NP_lconf = NP_lconf + j
      end do
      clmfrac(1:nsp) = 0.0
      do i = 1, cluster_id
         j = cluster(i)%clsize
         molfrac(:) = 0.0
         do k = 1, j
            ip = cluster(i)%members(k)
            if (itype(ip > nsp)) then
                  write(*,*) 'Error: particle type ', itype(ip), &
                  ' is larger than nsp = ', nsp
                  stop
            end if
            molfrac(itype(ip)) = molfrac(itype(ip)) + 1.0
         enddo
         cluster(i)%molfrac(:) = molfrac(:)/j
         clmfrac(:) = clmfrac(:) + molfrac(:)/j
      enddo
      clmfracav(:) = clmfracav(:)+clmfrac(:)/maxcln
      ! Write particle id, type, charge and position for last configuration
      if (Iconf == Nconf) then
         ! Write shape file
         do i = 1, nmaxcl
            if (countcl(i) > 0) then
               dsph(i) = dsph(i)/countcl(i)
               dratio(i) = dratio(i)/countcl(i)
            else
               dsph(i) = 0.0
               dratio(i) = 0.0
            end if
            write(io_shape_file, '(i5,f15.7,f15.7)') i, dsph(i), dratio(i)
         end do
         close(io_shape_file)
      end if
      ekincl = 0
      ekincls = 0
      suma = 0
      !
      ! Determine single cluster kinetic energies and inter-cluster kinetic contribution
      !
      do i = 1, cluster_id
         suma = suma + cluster(i)%clsize
         ekincl = ekincl + 0.5*cluster(i)%mass&
            &*dot_product(cluster(i)%vl(:), cluster(i)%vl(:))
         ekincls = ekincls + cluster(i)%ekin
      end do
      ekclaver = ekclaver + ekincl
      ekinclsav = ekinclsav + ekincls
      write (io_clusevol_file, '(i7,i7,f15.7,8f8.4)') iconf, cluster_id, & 
      &      (suma/natms)*100, clmfracav(1:nsp-1)/iconf
      if (iconf > 1) then
         deallocate (rclxyz)
         deallocate (rclxyzd)
         deallocate (densav)
      end if
      allocate (rclxyz(ndim, cluster_id), densav(cluster_id))
      allocate (rclxyzd(ndim, cluster_id))
      if (.not.allocated(densclus)) then
         allocate(densclus(0:ndrho))
      end if
      if (iconf == 1) then
         nmaxcl = 1000
         allocate(dratio(1:nmaxcl), dsph(1:nmaxcl), countcl(1:nmaxcl))
         densclus(0:ndrho) = 0.0
      end if
      rclxyz(:,:) = 0.0
      rclxyzd(:,:) = 0.0
      gcluster(:) = 0
      densav(:) = 0.0
      rhoclus(:) = 0
      denscl = 0.0
      rclus = 0.0
      im = 0
      !
      ! Determine cluster radii, density ..
      !
      do i = 1, cluster_id
         clussize = cluster(i)%clsize
         im = im + 1
         clcent(:) = cluster(i)%center(1:ndim)
         rclxyz(1:ndim, im) = clcent(1:ndim)
         rcluster = radius(cluster(i)%members(:), clussize, clcent, sidel)
         cluster(i)%radio = rcluster
      end do
      !
      ! Resize arrays if necessary
      !
      if (iconf==1) Then
         rmcl = maxval(cluster(1:cluster_id)%radio)  
         drclus = 2*rmcl/ndrclus
         if (2*maxval(cluster(1:cluster_id)%clsize) > nmaxcl) then
            write(*,'(" *** Warning !!: increasing nmaxcl=",i4," to ",i4)') nmaxcl, 2*maxval(cluster(1:cluster_id)%clsize)
            nmaxcl = 2*maxval(cluster(1:cluster_id)%clsize)
            deallocate (dratio, dsph, countcl)
            allocate(dratio(1:nmaxcl), dsph(1:nmaxcl), countcl(1:nmaxcl))
         end if
!         nmaxcl = 2*maxval(cluster(1:cluster_id)%clsize)
      endif
      averg = 0
      im = 0
      do i = 1, cluster_id
         clussize = cluster(i)%clsize
         clcent(:) = cluster(i)%center(1:ndim)
         rclxyz(1:ndim, i) = clcent(1:ndim)
         ! Radius of gyration
         cluster(i)%rg = radiusrg(cluster(i)%members(:), clussize, &
            & clcent, sidel,cluster(i)%mass)
         averg = averg+cluster(i)%rg
         if (ndim == 3) then
               volcl = (4*pi*rcluster**3/3.0)
         else
               volcl = pi*rcluster**2
         end if
         cluster(i)%cldens = real(clussize)/volcl
         indr = nint(cluster(i)%rg/drclus)
         if (indr <= ndr) radii(indr) = radii(indr) + 1
         denscl = denscl + cluster(i)%cldens
         rclus = rclus + rcluster
         ! Determine maximum cluster density
         if (cluster(i)%cldens > cdmax) then
               cdmax = cluster(i)%cldens
         endif
      end do
      avrg = avrg +averg/maxcl
      rclxyzd(:, :) = rclxyz(:, :)
      if (iconf == 1) then
         drho = 2*cdmax/ndrho
      end if
      ! Cluster density distribution
      do i = 1, cluster_id
         clussize = cluster(i)%clsize
         ind = nint(cluster(i)%cldens/drho)
         if (ind <= ndrho) densclus(ind) = densclus(ind) + 1
      end do

      !
      ! Compute cluster-cluster structure factor
      !
      if (run_sq) then
         call sqfnDcl<<<tBlock, grid>>>(rclxyzd, cluster_id, maxcl, ndim, fk_d, sqfcl_d, nqmax, qmin2, dq)
      endif
      averdens = averdens + denscl/maxcln
      avradio = avradio + rclus/maxcln
      ! Determine average cluster density, cluster g(r) and density profiles, cluster shape
      countlarge = 0
      do i = 1, cluster_id
         j = cluster(i)%clsize
         densav(i) = cldens(ndim, cluster(i)%members(:), j, sidel&
            &, side2, cluster(i)%center(1:ndim), 0.8*cluster(i)%radio)
         cmin = minj(ndim, cluster(i)%members, j &
            &, cluster(i)%center, sidel, side2)
         ! Cluster shape (ratio=0 for cylinders, ratio=1 for spheres)
         call cshape(ndim, cluster(i)%members(:), j, &
            & cluster(i)%center(1:ndim), sidel, side2,&
            & cluster(i)%ratio, cluster(i)%devsphere)
         if (j <= nmaxcl) then
               dsph(j) = dsph(j) + cluster(i)%devsphere
               dratio(j) = dratio(j) + cluster(i)%ratio
               countcl(j) = countcl(j) + 1
         end if
         if (densav(i) > 1.0e-6) then
               countlarge = countlarge+1
               ! Internal cluster g(r) is only calculared inside clusters with average density 
               ! > 0
            call rdfcl(ndim, cluster(i)%members(:), j, sidel&
               &, side2, gcluster, lsmax, deltar, densav(i), cmin)
         endif
         call denspcl(ndim, cluster(i)%members(:), j, sidel, side2&
            &, rhoclus(0:ndrclus), ndrclus, drclus, cluster(i)%center(1:ndim))
      end do
      if (countlarge>0) then
         gclustav(:) = gclustav(:) + gcluster(:)/maxcln
      endif
      rhoclusav(0:ndrclus) = rhoclusav(0:ndrclus) + rhoclus(0:ndrclus)/maxcln
      !
      ! Cluster-cluster pdf
      !
      call rdfclcl2(ndim, rclxyz(1:ndim, 1:cluster_id), cluster_id, maxcln, sidel&
      &, nrandom, side2, gclcl, gclr, gclr2, lsmax, deltar, volumen)
      NTclus = suma + NTclus
      ! Potential Energy
      if (run_thermo .and. iconf ==1 ) call thermo_init_cluster(natms, ndim, sidel, side2, maxcln, cluster)
   end subroutine cluster_analysis

   subroutine neighbor_search()
      !
      ! Main neighbor search call
      !
      use mod_common
      use mod_thrust
      use mod_input
      use mod_cells
      implicit none
      integer :: istat
      real :: time_gpu
      Character :: error_msg*64
      !
      ! Build neighbor tables for graph constructtion
      !
      istat = cudaEventRecord(startEvent, 0)
      if (use_cell) then
         call gpu_graph_cell<<<nbcuda, nthread>>>(r_d, Nmol, ndim, rcl**2, sidel_d, kmin)
      else
         call gpu_graf<<<nbcuda, nthread>>>(r_d, Nmol, ndim, rcl**2, sidel_d, kmin)
      end if
      time_gpu = gptime(stopEvent, startEvent)
      tgraph = tgraph + time_gpu
      goffset(:) = gneighbors(:)
      neighbors(:) = gneighbors(:)
      core(:) = gcore(:)
      istat = cudaEventRecord(startEvent, 0)
      call thrustscan(goffset, Nmol, 1)
      time_gpu = gptime(stopEvent, startEvent)
      tthrus = tthrus + time_gpu
      offset(:) = goffset(:)
      istat = cudaEventRecord(startEvent, 0)
      if (use_cell) then
         call gpu_adj_cell<<<nbcuda, nthread>>>(r_d, Nmol, ndim, rcl**2, sidel_d)
      else
         call gpu_adj<<<nbcuda, nthread>>>(r_d, Nmol, ndim, rcl**2, sidel_d)
      end if
      time_gpu = gptime(stopEvent, startEvent)
      tadj = tadj + time_gpu
      adjacency(:) = gadjacency(:)
   end subroutine neighbor_search

   subroutine cluster_search()
      !
      ! Main cluster search call
      !
      use mod_common
      use mod_thrust
      use mod_input
      use mod_cells
      implicit none
      integer :: cluster_id, i, j, istat
      real :: time_gpu
      Character :: error_msg*64
      !
      ! Search for neighbors and build graph
      !
      call neighbor_search()
      ! !
      gdone(:) = 0
      done(:) = 0
      cluster_id = 0
      visited(:) = .false.
      ! Recursive BFS search of connected clusters
      istat = cudaEventRecord(startEvent, 0)
      ! 
      ! Main loop over all particles
      ! (remains to be optimized in parallel)
      do i = 1, nmol
         if (core(i) .and. done(i) == 0) then
            gvisited(:) = .false.
            cluster_id = cluster_id + 1
            call breadfirst(i, nbcuda, nthread, Nmol, kmin, cluster_id, border, visited, done)
         end if
      end do
      time_gpu = gptime(stopEvent, startEvent)
      tbfs = tbfs + time_gpu
      ! Check for redimensioning of neighbor list
      if (maxval(neighbors(:)) > 60) then
         write (error_msg, '(" Warning:redimension next to at least ", i5)') maxval(neighbors(:))
         stop(error_msg)
      end if
      maxcln = cluster_id
   end subroutine cluster_search

   subroutine breadfirst(i, nbcuda, nthread, Nmol, kmin, cluster_id, border, visited, done)
      use mod_cells
      integer, intent(IN) :: Nmol, cluster_id, kmin, i, nbcuda, nthread
      integer, intent(INOUT) :: done(Nmol)
      logical(kind=1), intent(INOUT) :: visited(Nmol), border(Nmol)
      logical(kind=1) :: gb
      integer :: j
      border(i) = .true.
      gborder(i) = .true.
      do while (count(border == .true.) .ne. 0)
         call gbfs<<<nbcuda, nthread>>>(Nmol, gvisited, gborder, cluster_id, kmin)
         border(:) = gborder(:)
      end do
      visited(:) = gvisited(:)
      do j = 1, nmol
         if (visited(j)) then
            done(j) = cluster_id
         end if
      end do
   end subroutine breadfirst

   subroutine clusters_sq_init()
      use mod_common, only: ndr
      implicit none

      allocate (radii(0:ndr))
      radii(:) = 0

   end subroutine clusters_sq_init

   subroutine clusters_init(nmol)
      implicit none
      integer, intent(in) :: nmol

      ! Allocate CPU memory
      allocate (sizedist(nmol))

      ! Init variables
      sizedist(:) = 0.0
      ekclaver = 0.0
      ekinclsav = 0.0
      write(*,"(//' *** Clusters module initializing: G-DBSCAN starts from ',&
      i0'-particle clusters (recomended kmin>= 2*dim+1=',i0,')'/)") kmin,2*ndim+1
      ! Open output files
      open (newunit=io_centers_file, file=centers_filename)
      open (newunit=io_clusevol_file, file=clusevol_filename)
      open (newunit=io_shape_file, file=fshape_filename)
      write (io_clusevol_file,"('# conf no. clusters % particles in cluster ', &
      & 8('x_av(',i1,')':))")nsp-1
      write (io_shape_file, '("# cluster size, average deviation spherical shape, &
      & average dev axial symmetry")')

   end subroutine clusters_init




   subroutine clusters_clear()
      implicit none


      ! Clean house
      ! deallocate (sizedist)
      deallocate (densclus)
      deallocate (radii)
      deallocate (dratio, dsph, countcl)

      ! Close open files
      close (io_centers_file)
      close (io_clusevol_file)

   end subroutine clusters_clear

   subroutine denspcl(dim, members, nm, sidel, side2, rho, lsmax, deltar, center)
      integer, intent(IN) :: nm, lsmax, dim
      integer, intent(IN) :: members(nm)
      real, intent(IN) :: sidel(3), center(3), deltar, side2
      real, intent(INOUT) :: rho(0:lsmax)
      real :: rv(3), rr2, rr, fact
      integer :: k, l, i, j, ind
      ! g(r) is normalized for each configuration,
      ! since particle number may change
      do k = 1, nm
         i = members(k)
         rv(1:dim) = r(1:dim, i) - center(1:dim)
         ! PBC (unwrap if necessary)
         rv(1:dim) = rv(1:dim) - sidel(1:dim)*nint(rv(1:dim)/sidel(1:dim))
         rr2 = Dot_product(rv(1:dim), rv(1:dim))
         if (rr2 <= side2)then
            rr = sqrt(rr2)
            ind = Nint(rr/deltar)
            if(ind>0.and.ind<=lsmax) rho(ind) = rho(ind) + 1.0
         endif
      end do
   end subroutine denspcl

   function minj(dim, members, nm, center, sidel, side2)
      integer, intent(IN) :: nm, dim
      integer, intent(IN) :: members(nm)
      real, intent(IN) :: center(3), sidel(3), side2
      real :: rv(3), dist, r2
      integer :: j, i, kmin, minj
      dist = 100000000.0
      do j = 1, nm
         i = members(j)
         rv(1:dim) = r(1:dim, i) - center(1:dim)
         rv(1:dim) = rv(1:dim) - sidel(1:dim)*nint(rv(1:dim)/sidel(1:dim))
         r2 = dot_product(rv(1:dim), rv(1:dim))
         if (r2 <= dist) then
            dist = r2
            kmin = j
         end if
      end do
      minj = kmin
   end function minj

   subroutine cshape(dim, members, nm, center, sidel, side2, ratio, &
      & devsphere)   
      integer, intent(IN) :: nm, dim
      integer, intent(IN) :: members(nm)
      real(myprec), intent(IN) :: center(3), sidel(3), side2
      real(myprec), intent(OUT) :: ratio, devsphere
      real :: rv(3), inerc(3,3), trace, ozz, dd2 
      integer :: j, i
      ! Shape of the cluster is determined by the inertia tensor
      ! Inertia tensor is calculated as the sum of outer products of
      ! the position vectors of the particles in the cluster
      ! with respect to the geometric center of the cluster
      ! The inertia tensor is diagonalized to obtain the principal axes
      ! Calculate inertia tensor
      inerc(1:dim, 1:dim) = 0.0
      do i = 1, nm
         rv(1:dim) = r(1:dim, members(i)) - center(1:dim)
         rv(1:dim) = rv(1:dim) - sidel(1:dim)*nint(rv(1:dim)/sidel(1:dim))
         if (dim == 3) then
            ! 3D inertia tensor
            inerc(1:dim, 1:dim) = inerc(1:dim, 1:dim) + outer_product(rv(1:dim), rv(1:dim))
         else
            ! 2D inertia tensor
            inerc(1:dim, 1:dim) = inerc(1:dim, 1:dim) + outer_product2(rv(1:dim), rv(1:dim))
         end if
         inerc(1:dim, 1:dim) = inerc(1:dim, 1:dim) + outer_product(rv(1:dim), rv(1:dim))
      end do

      ! Diagonalize inertia tensor
      call diag(inerc,dim)
      ozz = inerc(dim,dim)
      if (dim == 3) then
         ! Write principal axes
         dd2 = inerc(1,1)**2 + inerc(2,2)**2 + ozz**2
         if (dd2 > 1.0d-10) then
            trace = (inerc(1,1) + inerc(2,2) + ozz)/ 3.0
            ! ratio = 0 for axial symmetry
            ratio = (inerc(2,2) - inerc(1,1)) / sqrt(dd2) 
            ! Calculate deviation from spherical shape
            devsphere = sqrt(((inerc(1,1) - trace)**2 + (inerc(2,2) - trace)**2 &
             & + (ozz - trace)**2)/dd2)
         else
            ratio = 0.0
            devsphere = 0.0
         end if
      else
         trace = (inerc(1,1) + ozz) / 2.0
         dd2 = inerc(1,1)**2 + ozz**2
         if (dd2 > 1.0d-10) then
            ! ratio = 0 for axial symmetry
            ratio = (ozz-inerc(1,1)) /sqrt(dd2) 
            devsphere = sqrt(((inerc(1,1) - trace)**2 + (ozz - trace)**2) / dd2)
         endif
      end if
   end subroutine cshape

   subroutine diag(inerc,dim)
      implicit none
      integer, intent(IN) :: dim
      real, intent(INOUT) :: inerc(:,:)
      ! Diagonalize 3x3 inertia tensor
      ! using LAPACK 
      integer, parameter :: lwork = 9
      integer :: info, i
      real :: d(dim), e(lwork)
      integer :: g(lwork)
      ! Call LAPACK routine to diagonalize the matrix
      ! Note: Make sure to link against LAPACK when compiling
      call ssyev('N', 'U', dim, inerc, 3, d, e, lwork, info)
      inerc(:,:) = 0.0
      do i=1,dim
         inerc(i,i) = d(i)
      enddo
   end subroutine diag

   function cldens(dim, members, nm, sidel, side2, center, rclus)
      integer, intent(IN) :: nm, dim
      integer, intent(IN) :: members(nm)
      real, intent(IN) :: sidel(3), side2, center(3), rclus
      real :: avcldens
      real :: rv(3), vol, rr2, rclus2
      integer :: i, j, count
      if (dim == 3) then
         vol = 4*pi*rclus**3/3.0
      else
         vol = 4*pi*rclus**2
      end if
      rclus2 = rclus*rclus
      count = 0
      do i = 1, nm
            j = members(i)
            if (j<=0 .or.j>natoms) then
                write(*,*) 'Error: particle id ', j, ' is out of range (1:', natoms, ')'
               stop
            end if   
            rv(1:dim) = r(1:dim, j) - center(1:dim)
            ! PBC (unwrap if necessary)
            rv(1:dim) = rv(1:dim) - sidel(1:dim)*nint(rv(1:dim)/sidel(1:dim))
            rr2 = Dot_product(rv(1:dim), rv(1:dim))
            if (rr2 < rclus2) then
               count = count + 1
            end if
      end do
      cldens = real(count)/vol
   end function cldens

   function radius(members, nm, center, sidel)
      implicit none
      integer, intent(IN) :: nm
      integer, intent(IN) :: members(nm)
      real(myprec), intent(IN) :: center(3), sidel(3)
      real(myprec) :: rr2, rv(3)
      integer :: i
      real(myprec) :: radius
      radius = 0
      do i = 1, nm
         rv(:) = r(:, members(i)) - center(:)
         rv = rv - sidel*nint(rv/sidel)
         rr2 = Dot_product(rv, rv)
         if (rr2 > radius) radius = rr2
      end do
      radius = sqrt(radius)
   end function radius

   function radiusRg(members, nm, center, sidel, masat)
      ! Radius of gyration
      implicit none
      integer, intent(IN) :: nm
      integer, intent(IN) :: members(nm)
      real(myprec), intent(IN) :: center(3), sidel(3), masat
      real(myprec) :: rr2, mt, rv(3)
      integer :: i, ip
      real(myprec) :: radius
      radiusrg = 0
      do i = 1, nm
         ip = members(i)
         rv(:) = r(:, ip) - center(:)
         rv = rv - sidel*nint(rv/sidel)
         rr2 = Dot_product(rv, rv)
         radiusrg = radiusrg+masa(ip)*rr2
      end do
      radiusrg = sqrt(radiusrg/masat)
   end function radiusRg

end module mod_clusters
