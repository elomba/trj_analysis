module mod_clusters
   ! Module for cluster analysis, including cluster search and calculation of cluster properties
   ! Cluster search is performed with a GPU implementation of the DBSCAN algorithm, which identifies
   ! clusters as connected components of a graph where edges are defined by a distance cutoff. 
   ! The GPU implementation allows for efficient cluster search in large systems.
   use mod_precision
   use mod_common
   use mod_input
   use mod_sq
   use mod_rdf
   use mod_densprof
   use mod_thermo
   use cudafor
   use mod_nc_conf, only : conf, wtypes, natoms, imol
   implicit none
   integer :: io_centers_file=110, io_clusevol_file=111, io_shape_file=112, nmaxcl
   character(len=17) :: centers_filename = 'centers.lammpstrj'
   character(len=12) :: clusevol_filename = 'clusevol.dat'
   character(len=10) :: fshape_filename = 'fshape.dat'
   integer, allocatable :: countcl(:)
   Real(myprec), allocatable, save :: molfrac(:), clmfrac(:)
   Real(myprec), allocatable :: clmfracav(:), dsph(:), dratio(:)
   Real(myprec), allocatable :: cluster_order_cos(:,:), cluster_order_sin(:,:), cluster_ql(:,:), &
      avcluster_order_cos(:), avcluster_order_sin(:), avcluster_order(:)
   interface
   ! Interface for cluster properties calculation
   ! Cluster properties are calculated only for clusters larger than a certain size threshold, to save time.
   ! Cluster properties include: internal density, cluster g(r), cluster shape, cluster-cluster structure factor ...
   ! Cluster properties are calculated with CPU routines, since they are only calculated for a small number of clusters
   ! Cluster properties are calculated with respect to the geometric center of the cluster, which is determined with PBC. 
   ! The geometric center is used to avoid biasing the cluster properties by the position of the particles in the cluster, 
   ! which can be affected by PBC.
   ! The cluster shape is determined by the inertia tensor of the cluster, which is calculated with respect to the geometric center.
   ! The cluster-cluster structure factor is calculated with a GPU routine, since it involves a double loop over 
   ! clusters and can be time consuming for large systems.
   ! The cluster g(r) is calculated with a CPU routine
   ! The cluster density profile is calculated with a CPU routine, since it involves a loop over particles in the cluster 
   !
   !
      function minj(dim, members, nm, center, sidel, side2)
         use mod_precision
         integer, intent(IN) :: nm, dim
         integer, intent(IN) :: members(nm)
         real, intent(IN) :: center(3), sidel(3), side2
      end function minj

      function cldens(dim, members, nm, sidel, side2, center, rclus)
         use mod_precision
         integer, intent(IN) :: nm, dim
         integer, intent(IN) :: members(nm)
         real, intent(IN) :: sidel(3), side2, center(3), rclus
         real :: avcldens
      end function cldens

      function radius(members, nm, center, sidel)
         use mod_precision
         integer, intent(IN) :: nm
         integer, intent(IN) :: members(nm)
         real(myprec), intent(IN) :: center(3), sidel(3)
      end function radius

      function radiusRg(members, nm, center, sidel, masat)
         use mod_precision
         integer, intent(IN) :: nm
         integer, intent(IN) :: members(nm)
         real(myprec), intent(IN) :: center(3), sidel(3), masat
      end function radiusRg
   end interface
contains

   subroutine cluster_analysis(Iconf)
      !
      ! Compute cluster properties
      ! Cluster properties are calculated only for clusters larger than a certain size threshold, to save time.
      ! 
      !
      implicit none
      integer, intent(IN) :: Iconf
      integer :: i, j, k, cluster_id, icl, ip, ind, indr, maxcl,&
      & imaxcl, clsz, clussize, cmin, NP_lconf, icount, im, countlarge
      Real(myprec), Dimension(3) ::  c0, rv, rv2, rvi, rvj, desp, xi, si, xss, sss, theta, clcent, vcl
      Real(myprec) :: denscl, rmcl, cdmax=0, factorv
      Real(kind=8) ::  mcl, ekcls, suma, rclus, rcluster, rgsum, averg, volcl
      if (iconf==1) call clusters_init(nmol)
      ! Cluster dynamics in picoseconds, to convert to velocity units if needed
      if (conf(4)%units == 'femtosecond' ) factorv = 0.001
      ! Correct cluster number if too small, to avoid problems with array allocation
      if (maxcln < 1) maxcln = 1
      call memory_manager_cluster(maxcln)
      Cluster_id = maxcln
      contador(:) = 0
      maxcl = 0
      ! 
      ! Allocate size for cluster structure
      do i = 1, cluster_id
         clsz = count(label == i)
         if (clsz > maxcl) then
            maxcl = clsz
            imaxcl = i
         end if
         cluster(i)%clsize = clsz
         allocate (cluster(i)%members(clsz))
         allocate (cluster(i)%molfrac(nsp))
         !
      end do
      ! 
      ! Assign perticles to clusters
      contador(:) = 0
      do i = 1, Nmol
         j = label(i)
         if (j > 0) then
            contador(j) = contador(j) + 1
            cluster(j)%members(contador(j)) = i
         end if
      end do
      clusid(:) = 0
      do i = 1, cluster_id
         ! identify to which cluster belongs each particle
         do j = 1, cluster(i)%clsize
            clusid(cluster(i)%members(j)) = I
         end do
      end do
      clusid_d(1:nmol) = clusid(1:nmol)
      !
      ! Write trajectory file with centers of mass of clusters if sufficient clusters found
      !
      if (maxcln > cl_thresh) then
         call centers_header(io_centers_file, nstep, maxcln, ex_vel)
      endif
      icl = 0
      cluster(:)%rg = 0
      if (Iconf == Nconf) NP_lconf = 0
      do I = 1, cluster_id
         j = cluster(i)%clsize
         ! Calculate cluster size distro
         ind = nint(real(j)/real(dcl))
         sizedist(ind) = sizedist(ind) + 1
         ! Determine center of mass with PBC
         ! https://en.wikipedia.org/wiki/Center_of_mass#Systems_with_periodic_boundary_conditions
         xss(:) = 0
         sss(:) = 0
         vcl(:) = 0
         mcl = 0
         ekcls = 0
         rgsum = 0.0
         do k = 1, j
            ip = cluster(i)%members(k)
            rv(1:ndim) = r(1:ndim, ip)
            theta(1:ndim) = 2*pi*rv(1:ndim)/sidelv(1:ndim)
            xss(1:ndim) = xss(1:ndim) + cos(theta(1:ndim))
            sss(1:ndim) = sss(1:ndim) + sin(theta(1:ndim))
            vcl(1:ndim) = vcl(1:ndim) + masa(ip)*vel(1:ndim, ip)
            mcl = mcl + masa(ip)
         end do
         xss(1:ndim) = xss(1:ndim)/j
         sss(1:ndim) = sss(1:ndim)/j
         theta(1:ndim) = atan2(-sss(1:ndim), -xss(1:ndim)) + pi
         !
         ! Restore origin for geometric centers  position to the original coordinate
         !
         cluster(i)%center(1:ndim) = sidelv(1:ndim)*theta(1:ndim)/(2*pi) + rlow(1:ndim)
         !
         ! Store cluster's center of mass velocity and net mass
         !
         cluster(i)%vl(1:ndim) = vcl(1:ndim)/mcl
         cluster(i)%mass = mcl
         ekcls = 0
         do k = 1, j
            ip = cluster(i)%members(k)
            ekcls = ekcls + 0.5*masa(ip)*dot_product(vel(:, ip)&
            &- cluster(i)%vl(:), vel(:, ip) - cluster(i)%vl(:))
         end do
         cluster(i)%ekin = ekcls
         ! Print trajectory file of clusters' mass centers
         if (maxcln > cl_thresh) then
            call centers_print(io_centers_file, i, ex_vel, factorv)
         endif
         if (Iconf == Nconf) NP_lconf = NP_lconf + j
      end do
      clmfrac(1:nsp) = 0.0
      ! Count particle types
      do i = 1, cluster_id
         j = cluster(i)%clsize
         molfrac(:) = 0.0
         do k = 1, j
            ip = cluster(i)%members(k)
            if (itype(ip > nsp)) then
               write(*,*) 'Error: particle type ', itype(ip), &
                  ' is larger than nsp = ', nsp
               stop
            end if
            molfrac(itype(ip)) = molfrac(itype(ip)) + 1.0
         enddo
         cluster(i)%molfrac(:) = molfrac(:)/j
         clmfrac(:) = clmfrac(:) + molfrac(:)/j
      enddo
      clmfracav(:) = clmfracav(:)+clmfrac(:)/maxcln

      ekincl = 0
      ekincls = 0
      suma = 0
      !
      ! Determine single cluster kinetic energies and inter-cluster kinetic contribution
      !
      do i = 1, cluster_id
         suma = suma + cluster(i)%clsize
         ekincl = ekincl + 0.5*cluster(i)%mass&
         &*dot_product(cluster(i)%vl(:), cluster(i)%vl(:))
         ekincls = ekincls + cluster(i)%ekin
      end do
      ekclaver = ekclaver + ekincl
      ekinclsav = ekinclsav + ekincls
      write (io_clusevol_file, '(i7,i7,f15.7,8f8.4)') iconf, cluster_id, &
      &      (suma/natms)*100, clmfracav(1:nsp-1)/iconf
      ! 
      ! resize arrays when needed
      if (iconf > 1) then
         deallocate (rclxyz)
         deallocate (rclxyzd)
         deallocate (densav)
      end if
      allocate (rclxyz(ndim, cluster_id), densav(cluster_id))
      allocate (rclxyzd(ndim, cluster_id))
      if (.not.allocated(densclus)) then
         allocate(densclus(0:ndrho))
         densclus(0:ndrho) = 0.0
      end if

      rclxyz(:,:) = 0.0
      rclxyzd(:,:) = 0.0
      gcluster(:) = 0
      densav(:) = 0.0
      rhoclus(:) = 0
      denscl = 0.0
      rclus = 0.0
      im = 0
      !
      ! Determine cluster radii, density ..
      !
      do i = 1, cluster_id
         clussize = cluster(i)%clsize
         im = im + 1
         clcent(:) = cluster(i)%center(1:ndim)
         rclxyz(1:ndim, im) = clcent(1:ndim)
         rcluster = radius(cluster(i)%members(:), clussize, clcent, sidel)
         cluster(i)%radio = rcluster
      end do
      !
      ! Resize arrays if necessary
      !
      if (iconf==1) Then
         rmcl = maxval(cluster(1:cluster_id)%radio)
         drclus = 2*rmcl/ndrclus
         if (2*maxval(cluster(1:cluster_id)%clsize) > nmaxcl) then
            write(*,'(" *** Warning !!: increasing nmaxcl=",i4," to ",i4)') nmaxcl, 2*maxval(cluster(1:cluster_id)%clsize)
            nmaxcl = 2*maxval(cluster(1:cluster_id)%clsize)
            deallocate (dratio, dsph, countcl)
            allocate(dratio(1:nmaxcl), dsph(1:nmaxcl), countcl(1:nmaxcl))
         end if
         dratio(:) = 0.0
         dsph(:) = 0.0
         countcl(:) = 0
      endif
      if (maxcln > cl_thresh)then
         ! Compute cluster properties (internal density, s(Q), g(r) ...) only if enough clusters found
         averg = 0
         im = 0
         do i = 1, cluster_id
            clussize = cluster(i)%clsize
            clcent(:) = cluster(i)%center(1:ndim)
            rclxyz(1:ndim, i) = clcent(1:ndim)
            ! Radius of gyration
            cluster(i)%rg = radiusrg(cluster(i)%members(:), clussize, &
            & clcent, sidel,cluster(i)%mass)
            averg = averg+cluster(i)%rg
            if (ndim == 3) then
               volcl = (4*pi*rcluster**3/3.0)
            else
               volcl = pi*rcluster**2
            end if
            cluster(i)%cldens = real(clussize)/volcl
            indr = nint(cluster(i)%rg/drclus)
            if (indr <= ndr) radii(indr) = radii(indr) + 1
            denscl = denscl + cluster(i)%cldens
            rclus = rclus + rcluster
            ! Determine maximum cluster density
            if (cluster(i)%cldens > cdmax) then
               cdmax = cluster(i)%cldens
            endif
         end do
         avrg = avrg +averg/maxcl
         rclxyzd(:, :) = rclxyz(:, :)
         if (iconf == 1) then
            drho = 2*cdmax/ndrho
         end if
         ! Cluster density distribution
         do i = 1, cluster_id
            clussize = cluster(i)%clsize
            ind = nint(cluster(i)%cldens/drho)
            if (ind <= ndrho) densclus(ind) = densclus(ind) + 1
         end do

         !
         ! Compute cluster-cluster structure factor
         !
         if (run_sq) then
            call sqfnDcl<<<tBlock, grid>>>(rclxyzd, cluster_id, maxcl, ndim, fk_d, sqfcl_d, nqmax, qmin2, dq)
         endif
         averdens = averdens + denscl/maxcln
         avradio = avradio + rclus/maxcln
         ! Determine average cluster density, cluster g(r) and density profiles, cluster shape
         countlarge = 0
         do i = 1, cluster_id
            j = cluster(i)%clsize
            densav(i) = cldens(ndim, cluster(i)%members(:), j, sidel&
            &, side2, cluster(i)%center(1:ndim), 0.8*cluster(i)%radio)
            cmin = minj(ndim, cluster(i)%members, j &
            &, cluster(i)%center, sidel, side2)
            ! Cluster shape (ratio=0 for cylinders, ratio=1 for spheres)
            call cshape(ndim, cluster(i)%members(:), j, &
            & cluster(i)%center(1:ndim), sidel, side2,&
            & cluster(i)%ratio, cluster(i)%devsphere)
            if (j <= nmaxcl) then
               dsph(j) = dsph(j) + cluster(i)%devsphere
               dratio(j) = dratio(j) + cluster(i)%ratio
               countcl(j) = countcl(j) + 1
            end if
            if (densav(i) > 1.0e-6) then
               countlarge = countlarge+1
               ! Internal cluster g(r) is only calculared inside clusters with average density
               ! > 0
               call rdfcl(ndim, cluster(i)%members(:), j, sidel&
               &, side2, gcluster, lsmax, deltar, densav(i), cmin)
            endif
            call denspcl(ndim, cluster(i)%members(:), j, sidel, side2&
            &, rhoclus(0:ndrclus), ndrclus, drclus, cluster(i)%center(1:ndim))
         end do
         if (countlarge>0) then
            gclustav(:) = gclustav(:) + gcluster(:)/maxcln
         endif
         rhoclusav(0:ndrclus) = rhoclusav(0:ndrclus) + rhoclus(0:ndrclus)/maxcln
         !
         ! Cluster-cluster pdf
         !
         call rdfclcl2(ndim, rclxyz(1:ndim, 1:cluster_id), cluster_id, maxcln, sidel&
         &, nrandom, side2, gclcl, gclr, gclr2, lsmax, deltar, volumen)
      endif
      NTclus = suma + NTclus
      if (maxcln > cl_thresh) then
         ! Write cluster shape file only for last frame
         if (Iconf == Nconf) then
            do i = 1, nmaxcl
               if (countcl(i) > 0) then
                  dsph(i) = dsph(i)/countcl(i)
                  dratio(i) = dratio(i)/countcl(i)
               else
                  dsph(i) = 0.0
                  dratio(i) = 0.0
               end if
               write(io_shape_file, '(i5,f15.7,f15.7)') i, dsph(i), dratio(i)
            end do
            close(io_shape_file)
         end if
      endif
      ! Potential Energy
      if (run_thermo .and. iconf ==1 ) call thermo_init_cluster(natms, ndim, sidel, side2, maxcln, cluster)
   end subroutine cluster_analysis

   subroutine memory_manager_cluster(maxcln)
      !
      ! Allocate memory for cluster properties, with size depending on the number of clusters found
      !
      implicit none
      integer, intent(IN) :: maxcln
      integer :: i
      !
      ! Memory management: deallocate and reallocate arrays if necessary, depending on the number of clusters found.
      ! Resize arrays if necessary
      if (allocated(cluster)) then
         deallocate (cluster, contador)
         if (run_order) then
            deallocate(cluster_order_cos)
            deallocate(cluster_order_sin)
            deallocate(cluster_ql)
         end if
         if (run_thermo) then
            deallocate(bigcl_d)
            deallocate(engcls,bigcl)
         endif
      else
         allocate(clusid(1:nmol))
         allocate(clusid_d(1:nmol))
         allocate(molfrac(1:nsp), clmfrac(1:nsp), clmfracav(1:nsp))
         clmfracav(1:nsp) = 0.0
         clmfrac(:) = 0.0
         molfrac(:) = 0.0
         nmaxcl = 1000
         allocate(dratio(1:nmaxcl), dsph(1:nmaxcl), countcl(1:nmaxcl))
         if (run_order) then
            allocate(avcluster_order_cos(norder))
            allocate(avcluster_order_sin(norder))
            allocate(avcluster_order(norder))
            avcluster_order_cos(:) = 0.0
            avcluster_order_sin(:) = 0.0
            avcluster_order(:) = 0.0
         end if
      end if
      allocate (cluster(maxcln), contador(maxcln))
      if (run_thermo) then
         allocate(bigcl_d(maxcln))
         allocate(engcls(maxcln),bigcl(maxcln))
      endif
      if (run_order) then
         allocate(cluster_order_cos(maxcln, norder))
         allocate(cluster_order_sin(maxcln, norder))
         allocate(cluster_ql(maxcln, norder))
         cluster_order_cos(:,:) = 0.0
         cluster_order_sin(:,:) = 0.0
         cluster_ql(:,:) = 0.0
      end if
   end subroutine memory_manager_cluster

   subroutine centers_header(io_centers_file, nstep, maxcln, ex_vel)
      !
      ! Write header of cluster centers trajectory file
      !
      implicit none
      integer, intent(IN) :: io_centers_file, nstep, maxcln
      logical, intent(IN) :: ex_vel
      integer :: i
      write (io_centers_file, "('ITEM: TIMESTEP'/I12/'ITEM: NUMBER OF ATOMS'/I12/'ITE&
      &M: BOX BOUNDS pp pp pp')") nstep, maxcln
      write (io_centers_file, "(2f15.7)") (0.0, sidel(i), i=1, ndim)
      if (ndim == 2) write (io_centers_file, "('-0.5 0.5')")
      if (ex_vel) then
         write (io_centers_file, "('ITEM: ATOMS id type x y z vx vy vz')")
      else
         write (io_centers_file, "('ITEM: ATOMS id type x y z')")
      end if
   end subroutine centers_header

   subroutine centers_print(io_centers_file, i, ex_vel, factorv)
      !
      ! Print cluster centers to trajectory file
      !
      implicit none
      integer, intent(IN) :: io_centers_file
      logical, intent(IN) :: ex_vel
      integer :: i
      real(myprec), intent(IN) :: factorv
      if (ex_vel) then
         if (ndim == 3) then
            write (io_centers_file, '(2i10,6f15.7)') i, 1, cluster(i)%center(1:ndim), factorv*cluster(i)%vl(1:ndim)
         else
            write (io_centers_file, '(2i10,6f15.7)') i, 1, cluster(i)%center(1:ndim), 0.0,factorv*cluster(i)%vl(1:ndim),0.0
         end if
      else
         if (ndim == 3) then
            write (io_centers_file, '(2i10,6f15.7)') i, 1, cluster(i)%center(1:ndim)
         else
            write (io_centers_file, '(2i10,6f15.7)') i, 1, cluster(i)%center(1:ndim), 0.0
         end if
      endif
   end subroutine centers_print

   subroutine neighbor_search()
      !
      ! Main neighbor search call
      !
      use mod_common
      use mod_thrust
      use mod_input
      use mod_cells
      implicit none
      integer :: istat
      real :: time_gpu
      Character :: error_msg*64
      !
      ! Build neighbor tables for graph constructtion
      !
      istat = cudaEventRecord(startEvent, 0)
      if (use_cell) then
         call gpu_graph_cell<<<nbcuda, nthread>>>(r_d, Nmol, ndim, rcl**2, sidel_d, kmin)
      else
         call gpu_graf<<<nbcuda, nthread>>>(r_d, Nmol, ndim, rcl**2, sidel_d, kmin)
      end if
      time_gpu = gptime(stopEvent, startEvent)
      tgraph = tgraph + time_gpu
      goffset(:) = gneighbors(:)
      neighbors(:) = gneighbors(:)
      core(:) = gcore(:)
      istat = cudaEventRecord(startEvent, 0)
      call thrustscan(goffset, Nmol, 1)
      time_gpu = gptime(stopEvent, startEvent)
      tthrus = tthrus + time_gpu
      offset(:) = goffset(:)
      istat = cudaEventRecord(startEvent, 0)
      if (use_cell) then
         call gpu_adj_cell<<<nbcuda, nthread>>>(r_d, Nmol, ndim, rcl**2, sidel_d)
      else
         call gpu_adj<<<nbcuda, nthread>>>(r_d, Nmol, ndim, rcl**2, sidel_d)
      end if
      time_gpu = gptime(stopEvent, startEvent)
      tadj = tadj + time_gpu
      adjacency(:) = gadjacency(:)
   end subroutine neighbor_search

   subroutine cluster_search()
      !
      ! Main cluster search call
      ! Code uses G-DBSCAN algorithm to identify clusters
      !
      use mod_common
      use mod_thrust
      use mod_input
      use mod_cells
      implicit none
      integer :: cluster_id, i, j, istat
      real :: time_gpu
      Character :: error_msg*64
      logical :: active
      logical, device :: active_d
      !
      ! Search for neighbors and build graph
      !
      call neighbor_search()
      ! !
      glabel(:) = 0
      label(:) = 0
      cluster_id = 0
      ! Recursive BFS search of connected clusters
      istat = cudaEventRecord(startEvent, 0)
      !
      ! Main loop over all particles
      do i = 1, nmol
         ! If i is a core particle and not yet assigned to a cluster, start a new cluster and expand it with BFS
         if (core(i) .and. label(i) == 0) then
            cluster_id = cluster_id + 1
            gborder(i) = .true.
            ! active is a flag to check if BFS expansion is still active, i.e. if new border nodes are being
            ! found. When no more border nodes are found, BFS is finished and we move to the next cluster.
            active = .true.
            ! Expand cluster with GPU BFS, starting from border nodes and
            ! expanding until no more border nodes found.
            do while (active)
               active_d = .false.
               call gbfs<<<nbcuda, nthread>>>(Nmol, gborder, gcore, glabel, cluster_id, kmin, active_d)
               istat = cudaDeviceSynchronize()
               active = active_d
            end do
            ! After BFS is finished, cluster_id is assigned to all particles in the cluster (label(:))
            ! and we move to the next unvisited core particle
            label(:) = glabel(:)
         end if
      end do
      time_gpu = gptime(stopEvent, startEvent)
      tbfs = tbfs + time_gpu
      ! Check for redimensioning of neighbor list
      if (maxval(neighbors(:)) > 60) then
         write (error_msg, '(" Warning:redimension next to at least ", i5)') maxval(neighbors(:))
         stop(error_msg)
      end if
      maxcln = cluster_id
   end subroutine cluster_search

   attributes(global) subroutine gbfs(Nmol, border, core, label, cluster_id, kmin, active)
   ! GPU BFS routine, uses neighbor lists to run through adjacent nodes, marks visited nodes and border nodes.
   ! Starts from border nodes and border is being expanded. Completely parallel implementation.
   integer, value, intent(IN) :: Nmol, cluster_id, kmin
   logical, intent(INOUT) :: active
   logical(kind=1), intent(INOUT) ::  border(Nmol), core(Nmol)
   integer, intent(INOUT) ::  label(Nmol)
   integer :: i, j, k
   j = (blockidx%x - 1)*blockdim%x + threadidx%x
   if (j <= Nmol) then
      if (border(j).and.label(j) == 0) then
         ! Mark cluster id for j, which is a border node, and if it is a core node,
         ! mark its neighbors as border for the next iteration
         ! label(j) marks node as visited and assigns cluster id to it,
         ! so that it is not visited again in the next BFS iterations
         label(j) = cluster_id
         if (core(j)) then
            ! Set flag to continue BFS expansion
            active = .true.
            ! Active cluster expansion: mark neighbors of j as border if not visited
            border(gadjacency(goffset(j):goffset(j)+gneighbors(j)-1)) = .true.
            ! do i = goffset(j), goffset(j) + gneighbors(j) - 1
            !    k = gadjacency(i)
            !    border(k) = .true.
            ! end do
         end if
      end if
   end if
end subroutine gbfs

subroutine clusters_sq_init()
   use mod_common, only: ndr
   implicit none

   allocate (radii(0:ndr))
   radii(:) = 0

end subroutine clusters_sq_init

subroutine clusters_init(nmol)
   implicit none
   integer, intent(in) :: nmol
   ! Allocate CPU memory
   allocate (sizedist(nmol))

   ! Init variables
   sizedist(:) = 0.0
   ekclaver = 0.0
   ekinclsav = 0.0
   write(*,"(//' *** Clusters module initializing: G-DBSCAN starts from ',&
      i0'-particle clusters (recomended kmin>= 2*dim+1=',i0,')'/)") kmin,2*ndim+1
   ! Open output files
   if (maxcln > cl_thresh) then
      open (io_centers_file, file=centers_filename)
      open (io_shape_file, file=fshape_filename)
   end if
   open (io_clusevol_file, file=clusevol_filename)
   write (io_clusevol_file,"('# conf no. clusters % particles in cluster ', &
   & 8('x_av(',i1,')':))")nsp-1
   write (io_shape_file, '("# cluster size, average deviation spherical shape, &
   & average dev axial symmetry")')

end subroutine clusters_init




subroutine clusters_clear()
   implicit none


   ! Clean house
   ! deallocate (sizedist)
   deallocate (densclus)
   deallocate (radii)
   deallocate (dratio, dsph, countcl)

   ! Close open files
   close (io_centers_file)
   close (io_clusevol_file)

end subroutine clusters_clear

subroutine denspcl(dim, members, nm, sidel, side2, rho, lsmax, deltar, center)
   integer, intent(IN) :: nm, lsmax, dim
   integer, intent(IN) :: members(nm)
   real, intent(IN) :: sidel(3), center(3), deltar, side2
   real, intent(INOUT) :: rho(0:lsmax)
   real :: rv(3), rr2, rr, fact
   integer :: k, l, i, j, ind
   ! g(r) is normalized for each configuration,
   ! since particle number may change
   do k = 1, nm
      i = members(k)
      rv(1:dim) = r(1:dim, i) - center(1:dim)
      ! PBC (unwrap if necessary)
      rv(1:dim) = rv(1:dim) - sidel(1:dim)*nint(rv(1:dim)/sidel(1:dim))
      rr2 = Dot_product(rv(1:dim), rv(1:dim))
      if (rr2 <= side2)then
         rr = sqrt(rr2)
         ind = Nint(rr/deltar)
         if(ind>0.and.ind<=lsmax) rho(ind) = rho(ind) + 1.0
      endif
   end do
end subroutine denspcl

function minj(dim, members, nm, center, sidel, side2)
   integer, intent(IN) :: nm, dim
   integer, intent(IN) :: members(nm)
   real, intent(IN) :: center(3), sidel(3), side2
   real :: rv(3), dist, r2
   integer :: j, i, kmin, minj
   dist = 100000000.0
   do j = 1, nm
      i = members(j)
      rv(1:dim) = r(1:dim, i) - center(1:dim)
      rv(1:dim) = rv(1:dim) - sidel(1:dim)*nint(rv(1:dim)/sidel(1:dim))
      r2 = dot_product(rv(1:dim), rv(1:dim))
      if (r2 <= dist) then
         dist = r2
         kmin = j
      end if
   end do
   minj = kmin
end function minj

subroutine cshape(dim, members, nm, center, sidel, side2, ratio, &
& devsphere)
   integer, intent(IN) :: nm, dim
   integer, intent(IN) :: members(nm)
   real(myprec), intent(IN) :: center(3), sidel(3), side2
   real(myprec), intent(OUT) :: ratio, devsphere
   real :: rv(3), inerc(3,3), trace, ozz, dd2
   integer :: j, i
   ! Shape of the cluster is determined by the inertia tensor
   ! Inertia tensor is calculated as the sum of outer products of
   ! the position vectors of the particles in the cluster
   ! with respect to the geometric center of the cluster
   ! The inertia tensor is diagonalized to obtain the principal axes
   ! Calculate inertia tensor
   inerc(1:dim, 1:dim) = 0.0
   do i = 1, nm
      rv(1:dim) = r(1:dim, members(i)) - center(1:dim)
      rv(1:dim) = rv(1:dim) - sidel(1:dim)*nint(rv(1:dim)/sidel(1:dim))
      if (dim == 3) then
         ! 3D inertia tensor
         inerc(1:dim, 1:dim) = inerc(1:dim, 1:dim) + outer_product(rv(1:dim), rv(1:dim))
      else
         ! 2D inertia tensor
         inerc(1:dim, 1:dim) = inerc(1:dim, 1:dim) + outer_product2(rv(1:dim), rv(1:dim))
      end if
      inerc(1:dim, 1:dim) = inerc(1:dim, 1:dim) + outer_product(rv(1:dim), rv(1:dim))
   end do

   ! Diagonalize inertia tensor
   call diag(inerc,dim)
   ozz = inerc(dim,dim)
   if (dim == 3) then
      ! Write principal axes
      dd2 = inerc(1,1)**2 + inerc(2,2)**2 + ozz**2
      if (dd2 > 1.0d-10) then
         trace = (inerc(1,1) + inerc(2,2) + ozz)/ 3.0
         ! ratio = 0 for axial symmetry
         ratio = (inerc(2,2) - inerc(1,1)) / sqrt(dd2)
         ! Calculate deviation from spherical shape
         devsphere = sqrt(((inerc(1,1) - trace)**2 + (inerc(2,2) - trace)**2 &
         & + (ozz - trace)**2)/dd2)
      else
         ratio = 0.0
         devsphere = 0.0
      end if
   else
      trace = (inerc(1,1) + ozz) / 2.0
      dd2 = inerc(1,1)**2 + ozz**2
      if (dd2 > 1.0d-10) then
         ! ratio = 0 for axial symmetry
         ratio = (ozz-inerc(1,1)) /sqrt(dd2)
         devsphere = sqrt(((inerc(1,1) - trace)**2 + (ozz - trace)**2) / dd2)
      endif
   end if
end subroutine cshape

subroutine diag(inerc,dim)
   implicit none
   integer, intent(IN) :: dim
   real, intent(INOUT) :: inerc(:,:)
   ! Diagonalize 3x3 inertia tensor
   ! using LAPACK
   integer, parameter :: lwork = 9
   integer :: info, i
   real :: d(dim), e(lwork)
   integer :: g(lwork)
   ! Call LAPACK routine to diagonalize the matrix
   ! Note: Make sure to link against LAPACK when compiling
   call ssyev('N', 'U', dim, inerc, 3, d, e, lwork, info)
   inerc(:,:) = 0.0
   do i=1,dim
      inerc(i,i) = d(i)
   enddo
end subroutine diag

function cldens(dim, members, nm, sidel, side2, center, rclus)
   integer, intent(IN) :: nm, dim
   integer, intent(IN) :: members(nm)
   real, intent(IN) :: sidel(3), side2, center(3), rclus
   real :: avcldens
   real :: rv(3), vol, rr2, rclus2
   integer :: i, j, count
   if (dim == 3) then
      vol = 4*pi*rclus**3/3.0
   else
      vol = 4*pi*rclus**2
   end if
   rclus2 = rclus*rclus
   count = 0
   do i = 1, nm
      j = members(i)
      if (j<=0 .or.j>natoms) then
         write(*,*) 'Error: particle id ', j, ' is out of range (1:', natoms, ')'
         stop
      end if
      rv(1:dim) = r(1:dim, j) - center(1:dim)
      ! PBC (unwrap if necessary)
      rv(1:dim) = rv(1:dim) - sidel(1:dim)*nint(rv(1:dim)/sidel(1:dim))
      rr2 = Dot_product(rv(1:dim), rv(1:dim))
      if (rr2 < rclus2) then
         count = count + 1
      end if
   end do
   cldens = real(count)/vol
end function cldens

function radius(members, nm, center, sidel)
   implicit none
   integer, intent(IN) :: nm
   integer, intent(IN) :: members(nm)
   real(myprec), intent(IN) :: center(3), sidel(3)
   real(myprec) :: rr2, rv(3)
   integer :: i
   real(myprec) :: radius
   radius = 0
   do i = 1, nm
      rv(:) = r(:, members(i)) - center(:)
      rv = rv - sidel*nint(rv/sidel)
      rr2 = Dot_product(rv, rv)
      if (rr2 > radius) radius = rr2
   end do
   radius = sqrt(radius)
end function radius

function radiusRg(members, nm, center, sidel, masat)
   ! Radius of gyration
   implicit none
   integer, intent(IN) :: nm
   integer, intent(IN) :: members(nm)
   real(myprec), intent(IN) :: center(3), sidel(3), masat
   real(myprec) :: rr2, mt, rv(3)
   integer :: i, ip
   real(myprec) :: radius
   radiusrg = 0
   do i = 1, nm
      ip = members(i)
      rv(:) = r(:, ip) - center(:)
      rv = rv - sidel*nint(rv/sidel)
      rr2 = Dot_product(rv, rv)
      radiusrg = radiusrg+masa(ip)*rr2
   end do
   radiusrg = sqrt(radiusrg/masat)
end function radiusRg

end module mod_clusters
