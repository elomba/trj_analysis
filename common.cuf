module cellp_props
    use mod_precision
    use cudafor
    implicit none
    integer :: maxpi, maxpj, maxpk, ncellp
    integer, device :: maxipd,maxjpd,maxkpd,ncellpd, nnpd
    integer, dimension(:), allocatable :: headp, listap
    integer, device, dimension(:), allocatable :: headpd, listapd
    integer, dimension(:,:), allocatable :: neighp
    integer, device, dimension(:,:), allocatable :: neighpd
    real(myprec) :: cellpx, cellpy, cellpz, rclp
    real(myprec), device :: cellxpd, cellypd, cellzpd
    logical :: use_cellp=.true.
end module cellp_props
module mod_common
    use mod_precision
    use cudafor
    implicit none

    Integer, Parameter :: npmx = 8192, nmblock = 500, nmgrid = 50000, &
                          nspmax = 4, nmolmax = 220000, nmesmax = 10000, nkmax = 200, ksmax = 6
    Integer, Parameter :: nitmax = nspmax*(nspmax + 1)/2
    real(myprec), parameter :: pi = 3.1415926535898D0, fconv = 4.135, &
                               rgas = 8.3144d7, aunit = 1.0d-8, tunit = 1.0d-12, &
                               kelvintokcal = 0.00198717, c_nktv=1.430933, kcal_a3_to_bar=6.948d6

    real(myprec) :: time_cpu_start, time_cpu_stop, time_total = 0_sp
    real(double) :: ekin, vir_i, suma
    type(cudaEvent) :: startEvent, stopEvent
    type(cudaDeviceProp) :: gpu_properties
    type(dim3) :: bl2, thr2, grid, tBlock
    integer, save :: nstep = 0
    integer :: nbcuda, natms, nmol, width, nqmax, nqwmax, lmaxx, lmaxy, lmaxz, &
               lsmax, nqmin, ndr, shmsize, maxthread, nit, nconf, nmzero = 0, maxcln, nrandom=0
    integer, allocatable, dimension(:) :: ntype, itype, lty, list, done, nq
    integer, allocatable, dimension(:, :) :: ipos, densprofi, histomixi
    integer (kind=2), allocatable, dimension(:,:) :: indqw
    integer, device, allocatable, dimension(:) :: itype_d, ntype_d, gdone
    real, device, allocatable, dimension(:) :: gii_d, g2ii_d
    integer, device, allocatable, dimension(:, :) :: ipos_d, densprof_d, histomix_d
    real(kind=8) :: vir_aver, ecaver
    real(myprec) :: tuniti, volumen, side, side2, dq, densty, Tfact, taver, &
                    temperature, rdenst, volumen_r, tstep
    real(myprec), dimension(3) :: sidel, rlow
    real, device, dimension(3) :: fk_d, sidel_d
    real(myprec), dimension(3, 3) :: cell
    real(myprec), allocatable, dimension(:) :: masa, bscat, sig2n, gaver
    real(kind=8), allocatable, dimension(:) :: gi, g2i, gii, g2ii
    real, device, allocatable, dimension(:) :: sqf_d, sqfcl_d, bsc_d
    real(myprec), allocatable, dimension(:, :) :: r, vel, force, densprof
    real, device, allocatable, dimension(:, :) :: r_d, v_d, rclxyzd, sqfp_d
    real(double), device, allocatable, dimension(:) :: engcl_d
    logical, allocatable, dimension(:) :: bigcl
    logical,  device, allocatable, dimension(:) :: bigcl_d
    real(double), allocatable, dimension(:) :: engcls, gclr, gclr2
    real(myprec), allocatable, dimension(:) :: engclclh
    real ::  qmin2, cpu0, cpu1
    real, dimension(3) :: fk
    real, allocatable, dimension(:) :: sqf, sqfcl, gcluster, gclustav, gclcl, rhoclus, &
                                       rhoclusav, sqcl
    real, allocatable, dimension(:, :) :: sqfp
    real, allocatable, dimension(:, :, :) :: histomix
    logical :: pdir(3) = .true., run_clusters = .false., run_rdf = .false., &
               run_sq = .false., run_dyn = .false., run_sqw = .false., run_thermo = .false.
    character :: fname99*18
    character, dimension(:), allocatable :: atoms*8
    real(myprec) :: epotperatom, epot
    integer, allocatable, dimension(:) :: epotperatomhistomixcl, epothistomixcl
    integer(kind=2), allocatable, dimension(:) :: clusid
    integer(kind=2), device, allocatable, dimension(:) :: clusid_d
    real(myprec) epotperatomcl_min, epotperatomcl_max, epotcl_min, epotcl_max, deltapotcl, deltapotperatomcl
    real(myprec), allocatable, dimension(:) :: epotclcldata
    real(myprec) :: epotclclmean, epotclclstdv
    logical :: ex_vel = .false., ex_force = .false., ex_mol = .false., periodic(3) = .true.

    type clus
        sequence
        real(myprec) :: vl(3)
        real(myprec) :: center(3)
        real(myprec) :: ekin
        real(myprec) :: radio
        real(myprec) :: rg
        real(myprec) :: cldens
        real(myprec) :: mass
        real(myprec) :: poteng
        real(myprec) :: potengperatom
        Integer :: clsize
        integer, allocatable :: members(:)
    end type clus
    type(clus), Allocatable :: cluster(:)
    Real(myprec), Dimension(:), Allocatable :: sizedist, densav
    Real(myprec), Dimension(:, :), Allocatable ::  rclxyz
    real(myprec) :: ekclaver, ekinclsav, ekincl, ekincls
    real(myprec) :: tadj = 0, tgraph = 0, tthrus = 0, tbfs = 0, tread = 0, &
                    & tsq = 0, tdyn=0, trdf = 0, tpoteng = 0
    real(myprec) :: avradio = 0, avrg=0, averdens = 0, tconf0 = 0, tconf1 = 0, drho
    integer, allocatable ::   radii(:), densclus(:), contador(:)
    integer :: Nu_clus, ndrho
    real(myprec) :: NTclus = 0

    integer, allocatable, dimension(:) :: offset, neighbors, adjacency
    integer, device, allocatable, dimension(:) :: goffset, gneighbors, gadjacency
    logical(kind=1), allocatable, dimension(:) :: visited, core, border
    logical(kind=1), device, allocatable, dimension(:) :: gvisited, gcore, gborder

    Real(myprec) :: cellx, celly, cellz
    Integer, Dimension(:), Allocatable :: head, lista
    Integer, Dimension(:, :), Allocatable:: neigh
    Integer :: ncell, nn, maxi, maxj, maxk

    Real(myprec), device :: cellxd, cellyd, cellzd
    Integer, device, Dimension(:), Allocatable :: headd, listad
    Integer, device, Dimension(:, :), Allocatable:: neighd
    Integer, device :: ncelld, maxid, maxjd, maxkd, nnd

    interface

        function minj(dim, members, nm, center, sidel, side2)
            use mod_precision
            integer, intent(IN) :: nm, dim
            integer, intent(IN) :: members(nm)
            real, intent(IN) :: center(3), sidel(3), side2
        end function minj

        function cldens(dim, members, nm, sidel, side2, center, rclus)
            use mod_precision
            integer, intent(IN) :: nm, dim
            integer, intent(IN) :: members(nm)
            real, intent(IN) :: sidel(3), side2, center(3), rclus
            real :: avcldens
        end function cldens

        function radius(members, nm, center, sidel)
            use mod_precision
            integer, intent(IN) :: nm
            integer, intent(IN) :: members(nm)
            real(myprec), intent(IN) :: center(3), sidel(3)
        end function radius

        function radiusRg(members, nm, center, sidel, masat)
            use mod_precision
            integer, intent(IN) :: nm
            integer, intent(IN) :: members(nm)
            real(myprec), intent(IN) :: center(3), sidel(3), masat
        end function radiusRg

        function vector_product(a, b)
            use mod_precision
            real(myprec), dimension(:), intent(in) :: a, b
            real(myprec), dimension(size(a)) :: vector_product
        end function vector_product

        subroutine common_init(natoms, ndim, nthread, idir, units, factor, nsp)
            use mod_precision
            integer, intent(in) :: natoms, ndim, nthread, idir, nsp
            real(myprec), intent(in) :: factor
            character(*), intent(in) :: units
        end subroutine common_init

        subroutine common_clear()
            use mod_precision
        end subroutine common_clear
    end interface

contains

subroutine printDeviceProperties(prop, num)
use cudafor
type(cudadeviceprop) :: prop
integer num, ilen
ilen = verify(prop%name, ' ', .true.)
write (*,900) "Device Number: "      ,num
write (*,901) "Device Name: "        ,prop%name(1:ilen)
write (*,903) "Total Global Memory: ",real(prop%totalGlobalMem)/1e9," Gbytes"
write (*,902) "sharedMemPerBlock: "  ,prop%sharedMemPerBlock," bytes"
write (*,900) "regsPerBlock: "       ,prop%regsPerBlock
write (*,900) "warpSize: "           ,prop%warpSize
write (*,900) "maxThreadsPerBlock: " ,prop%maxThreadsPerBlock
write (*,904) "maxThreadsDim: "      ,prop%maxThreadsDim
write (*,904) "maxGridSize: "        ,prop%maxGridSize
write (*,903) "ClockRate: "          ,real(prop%clockRate)/1e6," GHz"
write (*,902) "Total Const Memory: " ,prop%totalConstMem," bytes"
write (*,905) "Compute Capability Revision: ",prop%major,prop%minor
write (*,902) "TextureAlignment: "   ,prop%textureAlignment," bytes"
write (*,906) "deviceOverlap: "      ,prop%deviceOverlap
write (*,900) "multiProcessorCount: ",prop%multiProcessorCount
write (*,906) "integrated: "         ,prop%integrated
write (*,906) "canMapHostMemory: "   ,prop%canMapHostMemory
write (*,906) "ECCEnabled: "         ,prop%ECCEnabled
write (*,906) "UnifiedAddressing: "  ,prop%unifiedAddressing
write (*,900) "L2 Cache Size: "      ,prop%l2CacheSize
write (*,900) "maxThreadsPerSMP: "   ,prop%maxThreadsPerMultiProcessor
900 format (a,i0)
901 format (a,a)
902 format (a,i0,a)
903 format (a,f7.3,a)
904 format (a,2(i0,1x,'x',1x),i0)
905 format (a,i0,'.',i0)
906 format (a,l0)
return
end subroutine printDeviceProperties

subroutine printDevPropShort(prop, num)
use cudafor
type(cudadeviceprop) :: prop
integer num, ilen
ilen = verify(prop%name, ' ', .true.)
write (*,900) "-Running on Device Number: "      ,num
write (*,901) "-Device Name: "        ,prop%name(1:ilen)
write (*,903) "-Total Global Memory: ",real(prop%totalGlobalMem)/1e9," Gbytes"
write (*,905) "-Compute Capability Revision: ",prop%major,prop%minor
write (*,900) "-multiProcessorCount: ",prop%multiProcessorCount
write (*,900) "-maxThreadsPerSMP: "   ,prop%maxThreadsPerMultiProcessor
write (*,"(80('_')/)")
900 format (a,i0)
901 format (a,a)
902 format (a,i0,a)
903 format (a,f7.3,a)
904 format (a,2(i0,1x,'x',1x),i0)
905 format (a,i0,'.',i0)
906 format (a,l0)
return
end subroutine printDevPropShort

subroutine thermo_vir(iconf, ndim)
    !
    ! Compute virial contribution to the pressure
    !
    integer, intent(in) :: iconf, ndim
    integer :: i

    vir_i = 0.0
    Do i = 1, natms 
        vir_i = vir_i + dot_product(r(1:ndim,i),force(1:ndim,i))
    End Do
    vir_aver = vir_aver + vir_i
end subroutine thermo_vir

subroutine thermo_kin(iconf, ndim)
    !
    ! Compute kinetic energy and temperature
    !
    integer, intent(in) :: iconf, ndim
    integer :: i

    densty = natms/volumen

    ekin = 0.0
    Do i = 1, natms 
        ekin = ekin + masa(i)*Dot_product(vel(1:ndim, i)&
            &, vel(1:ndim, i))
    End Do
    ekin = 0.5d0*ekin
    ecaver = ecaver + ekin
    Tfact = (natms - nmzero - 1)*ndim
    Tfact = (natms - nmzero - 1)*ndim
    taver = 2*ecaver*(aunit/tunit)**2/(Tfact*Rgas*Iconf)
    temperature = 2*ekin*(aunit/tunit)**2/(Tfact*Rgas)
end subroutine thermo_kin

    function minj(dim, members, nm, center, sidel, side2)
        integer, intent(IN) :: nm, dim
        integer, intent(IN) :: members(nm)
        real, intent(IN) :: center(3), sidel(3), side2
        real :: rv(3), dist, r2
        integer :: j, i, jmin, minj
        dist = 100000000.0
        do j = 1, nm
            i = members(j)
            rv(1:dim) = r(1:dim, i) - center(1:dim)
            rv(1:dim) = rv(1:dim) - sidel(1:dim)*nint(rv(1:dim)/sidel(1:dim))
            r2 = dot_product(rv(1:dim), rv(1:dim))
            if (r2 <= dist) then
                dist = r2
                jmin = j
            end if
        end do
        minj = jmin
    end function minj

    function cldens(dim, members, nm, sidel, side2, center, rclus)
        integer, intent(IN) :: nm, dim
        integer, intent(IN) :: members(nm)
        real, intent(IN) :: sidel(3), side2, center(3), rclus
        real :: avcldens
        real :: rv(3), vol, rr2, rclus2
        integer :: i, j, count
        if (dim == 3) then
            vol = 4*pi*rclus**3/3.0
        else
            vol = 4*pi*rclus**2
        end if
        rclus2 = rclus*rclus
        count = 0
        do i = 1, nm
            j = members(i)
            rv(1:dim) = r(1:dim, j) - center(1:dim)
            ! PBC (unwrap if necessary)
            rv(1:dim) = rv(1:dim) - sidel(1:dim)*nint(rv(1:dim)/sidel(1:dim))
            rr2 = Dot_product(rv(1:dim), rv(1:dim))
            if (rr2 < rclus2) then
                count = count + 1
            end if
        end do
        cldens = real(count)/vol
    end function cldens

    function radius(members, nm, center, sidel)
        implicit none
        integer, intent(IN) :: nm
        integer, intent(IN) :: members(nm)
        real(myprec), intent(IN) :: center(3), sidel(3)
        real(myprec) :: rr2, rv(3)
        integer :: i
        real(myprec) :: radius
        radius = 0
        do i = 1, nm
            rv(:) = r(:, members(i)) - center(:)
            rv = rv - sidel*nint(rv/sidel)
            rr2 = Dot_product(rv, rv)
            if (rr2 > radius) radius = rr2
        end do
        radius = sqrt(radius)
    end function radius

    function radiusRg(members, nm, center, sidel, masat)
        ! Radius of gyration
        implicit none
        integer, intent(IN) :: nm
        integer, intent(IN) :: members(nm)
        real(myprec), intent(IN) :: center(3), sidel(3), masat
        real(myprec) :: rr2, mt, rv(3)
        integer :: i, ip
        real(myprec) :: radius
        radiusrg = 0
        do i = 1, nm
            ip = members(i)
            rv(:) = r(:, ip) - center(:)
            rv = rv - sidel*nint(rv/sidel)
            rr2 = Dot_product(rv, rv)
            radiusrg = radiusrg+masa(ip)*rr2
        end do
        radiusrg = sqrt(radiusrg/masat)
    end function radiusRg
    function gptime(stopEvent, startEvent)
        type(cudaEvent), intent(IN) :: startEvent, stopEvent
        integer :: istat
        real :: time, gptime
        istat = cudaEventRecord(stopEvent, 0)
        istat = cudaEventSynchronize(stopEvent)
        istat = cudaEventElapsedTime(time, startEvent, stopEvent)
        gptime = time/1000.0
    end function gptime

    function vector_product(a, b)
        use mod_precision
        real(myprec), dimension(:), intent(in) :: a, b
        real(myprec), dimension(size(a)) :: vector_product
        vector_product(1) = a(2)*b(3) - a(3)*b(2)
        vector_product(2) = -a(1)*b(3) + a(3)*b(1)
        vector_product(3) = a(1)*b(2) - a(2)*b(1)
    end function vector_product

    subroutine transfer_cpu_gpu(ndim)
        implicit none
        integer, intent(in) :: ndim

        ! side2 = (side/2)**2
        sidel_d(:) = sidel(:)
        r_d(1:ndim, 1:Nmol) = r(1:ndim, 1:Nmol)
        fk_d(:) = fk(:)
        itype_d(1:Nmol) = itype(1:Nmol)

    end subroutine transfer_cpu_gpu

    subroutine common_init(natoms, ndim, nthread, idir, units, factor, nsp)
        use mod_precision
        real(myprec), intent(in) :: factor
        integer, intent(in) :: natoms, ndim, nthread, idir, nsp
        character(*), intent(in) :: units

        nmol = natoms !! WARN, change when molecules are implemented
        natms = natoms !! WARN, assign for compatibility
        ! CUDA number of blocks
        nbcuda = Nmol/nthread
        if (nbcuda*nthread .ne. Nmol) nbcuda=nbcuda+1
        bl2 = dim3(Nmol/16, Nmol/16, 1)
        thr2 = dim3(16, 16, 1)

        ! Time unit load from netcdf, set in real type seconds units
        if (units == 'femtosecond') then
            tuniti = 1.0d-15
            tstep = factor*0.001
        else if (units == 'picosecond') then
            tuniti = 1.0d-12
            tstep = factor
        else
            print *, 'ERROR: timeunit ', units, ' not implemented!'
            stop
        end if

        ! Idir parameters control and set pdir
        if (idir > 0) then
            if (idir > ndim) stop(" ** Error : wrong non periodic dimension")
            pdir(idir) = .false.
        end if

        ! Allocate CPU memory
        allocate (atoms(nsp))
        allocate (ntype(nsp))
        allocate (lty(nsp))
        allocate (itype(nmol))
        allocate (ipos(nsp, nmol))
        allocate (bscat(nmol))
        allocate (masa(nmol))
        allocate (list(nmol))
        allocate (done(nmol))
        allocate (r(ndim, nmol))
        if (ex_vel) then
            allocate (vel(ndim, nmol))
            allocate (v_d(ndim, nmol))
        end if 
        if (ex_force) then
            allocate (force(ndim, nmol))
        end if

        ! Allocate GPU memory
        allocate (r_d(ndim, nmol))
        allocate (itype_d(nmol))
        allocate (ntype_d(nsp))
        allocate (bsc_d(nsp))
        allocate (ipos_d(nsp, nmol))
        allocate (gdone(nmol))

        ! Init variables
        ecaver = 0.0
        vir_aver = 0.0
        cell(:, :) = 0

    end subroutine common_init

    subroutine common_clear()
        use mod_precision

        ! Clean house
        deallocate (atoms)
        deallocate (ntype)
        deallocate (lty)
        deallocate (itype)
        deallocate (ipos)
        deallocate (bscat)
        deallocate (masa)
    end subroutine common_clear

end module mod_common
