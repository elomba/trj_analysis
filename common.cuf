module mod_common
   use mod_precision
   use cudafor
   implicit none

   Integer, Parameter :: npmx = 8192, nmblock = 500, nmgrid = 50000, &
      nspmax = 10, nmolmax = 220000, nmesmax = 10000, nkmax = 200, ksmax = 6
   Integer, Parameter :: nitmax = nspmax*(nspmax + 1)/2
   real(myprec), parameter :: pi = 3.1415926535898D0, fconv = 4.135, &
      rgas = 8.3144d7, aunit = 1.0d-8, tunit = 1.0d-12, &
      kelvintokcal = 0.00198717, c_nktv=1.380649d2, &
      kcal_a3_to_bar=69476.954109

   real(myprec) :: time_cpu_start, time_cpu_stop, time_total = 0_sp
   real(double) :: ekin, suma
   type(cudaEvent) :: startEvent, stopEvent
   type(dim3) :: bl2, thr2, grid, tBlock
   integer, save :: nstep = 0
   integer :: nbcuda, natms, nmol, width, nqmax, nqwmax, lmaxx, lmaxy, lmaxz, &
      lsmax, nqmin, ndr, shmsize, maxthread, nit, nconf, nmzero = 0, maxcln,&
      voigt, nrandom=0
   integer :: cntch(100), ncharge
   real(double), dimension(100) :: chgh
   integer, allocatable, dimension(:) :: ntype, itype, lty, list, done, nq
   integer, allocatable, dimension(:, :) :: ipos, densprofi, histomixi
   integer (kind=2), allocatable, dimension(:,:) :: indqw
   integer, device, allocatable, dimension(:) :: itype_d, ntype_d, gdone
   real, device, allocatable, dimension(:) :: gii_d, g2ii_d
   integer, device, allocatable, dimension(:, :) :: ipos_d, densprof_d, histomix_d
   real(kind=8) :: ecaver
   real(myprec) :: tuniti, volumen, side, side2, dq, densty, Tfact, taver, &
      temperature, rdenst, volumen_r, tstep, pwall, pwallp
   real(myprec), dimension(3) :: sidel, rlow
   real, device, dimension(3) :: fk_d, sidel_d
   real(myprec), dimension(3, 3) :: cell
   real(myprec), allocatable, dimension(:) :: masa, bscat, sig2n, gaver, u_p
   real(kind=8), allocatable, dimension(:) :: gi, g2i, gii, g2ii, qcharge
   real, device, allocatable, dimension(:) :: sqf_d, sqfcl_d, bsc_d
   real(myprec), allocatable, dimension(:, :) :: r, vel, force, densprof
   real(double), allocatable, dimension(:) :: qdensprof, dqminus, dqplus
   real(double),allocatable, dimension(:, :) :: stress
   real, device, allocatable, dimension(:, :) :: r_d, v_d, rclxyzd, sqfp_d
   logical, allocatable, dimension(:) :: bigcl
   logical,  device, allocatable, dimension(:) :: bigcl_d
   real(double), allocatable, dimension(:) :: engcls, gclr, gclr2
   real ::  qmin2, cpu0, cpu1
   real, dimension(3) :: fk
   real, allocatable, dimension(:) :: sqf, sqfcl, gcluster, gclustav, gclcl, rhoclus, &
      rhoclusav, sqcl
   real, allocatable, dimension(:, :) :: sqfp
   real, allocatable, dimension(:, :, :) :: histomix
   logical :: pdir(3) = .true., run_clusters = .false., run_rdf = .false., &
      run_sq = .false., run_dyn = .false., run_sqw = .false., run_thermo = .false., &
      confined = .false.
   character :: fname99*18
   character, dimension(:), allocatable :: atoms*8
   character(len=:), allocatable :: tunits
   character :: ener_name*12, press_name*12
   real(myprec) :: epotperatom, epot,epotav
   real(double) :: pressure, pressav, pxyz(6)
   integer, allocatable, dimension(:) :: epotperatomhistomixcl, epothistomixcl
   integer(kind=2), allocatable, dimension(:) :: clusid
   integer(kind=2), device, allocatable, dimension(:) :: clusid_d
   real(myprec) epotperatomcl_min, epotperatomcl_max, epotcl_min, epotcl_max, deltapotcl, deltapotperatomcl
   real(myprec), allocatable, dimension(:) :: epotclcldata
   real(myprec) :: epotclclmean, epotclclstdv
   logical :: ex_vel = .false., ex_force = .false., ex_stress = .false., &
   &  ex_mol = .false., ex_qc = .false., periodic(3) = .true.

   type clus
      sequence
      real(myprec) :: vl(3)
      real(myprec) :: center(3)
      real(myprec) :: ekin
      real(myprec) :: radio
      real(myprec) :: rg
      real(myprec) :: cldens
      real(myprec) :: mass
      real(myprec) :: poteng
      real(myprec) :: potengperatom
      real(myprec) :: ratio
      real(myprec) :: devsphere
      real(myprec), allocatable :: molfrac(:)
      Integer :: clsize
      integer, allocatable :: members(:)
   end type clus
   type(clus), Allocatable :: cluster(:)
   Real(myprec), Dimension(:), Allocatable :: sizedist, densav
   Real(myprec), Dimension(:, :), Allocatable ::  rclxyz
   real(myprec) :: ekclaver, ekinclsav, ekincl, ekincls
   real(myprec) :: tadj = 0, tgraph = 0, tthrus = 0, tbfs = 0, tread = 0, &
   & tsq = 0, tdyn=0, trdf = 0, tpoteng = 0
   real(myprec) :: avradio = 0, avrg=0, averdens = 0, tconf0 = 0, tconf1 = 0, drho
   integer, allocatable ::   radii(:), densclus(:), contador(:)
   integer :: Nu_clus, ndrho=200
   real(myprec) :: NTclus = 0

   integer, allocatable, dimension(:) :: offset, neighbors, adjacency
   integer, device, allocatable, dimension(:) :: goffset, gneighbors, gadjacency
   logical(kind=1), allocatable, dimension(:) :: visited, core, border
   logical(kind=1), device, allocatable, dimension(:) :: gvisited, gcore, gborder

   Real(double) :: cellx, celly, cellz
   Integer, Dimension(:), Allocatable :: head, lista
   Integer, Dimension(:, :), Allocatable:: neigh
   Integer :: ncell, nn, maxi, maxj, maxk

   Real(double), device :: cellxd, cellyd, cellzd
   Integer, device, Dimension(:), Allocatable :: headd, listad
   Integer, device, Dimension(:, :), Allocatable:: neighd
   Integer, device :: ncelld, maxid, maxjd, maxkd, nnd

   interface
      function vector_product(a, b) result(vv)
         use mod_precision
         real(myprec), dimension(:), intent(in) :: a, b
         real(myprec), dimension(size(a)) :: vv
      end function vector_product

      function outer_product(a, b) result(vv)
         use mod_precision
         real(myprec), dimension(:), intent(in) :: a, b
         real(myprec), dimension(size(a),size(b)) :: vv
      end function outer_product

      subroutine common_init(natoms, ndim, nthread, idir, units, factor, nsp)
         use mod_precision
         integer, intent(in) :: natoms, ndim, nthread, idir, nsp
         real(myprec), intent(in) :: factor
         character(*), intent(in) :: units
      end subroutine common_init
   end interface

contains

   subroutine printcudaerror(routine)
      use cudafor
      character(*) :: routine
      integer :: ierrsync
      ierrSync = cudaGetLastError()
      if (ierrSync /= cudaSuccess) write(*,*) &
         trim(routine)," kernel error:", cudaGetErrorString(ierrSync)
   end subroutine printcudaerror

   subroutine printDeviceProperties(prop, num)
      use cudafor
      type(cudadeviceprop) :: prop
      integer num, ilen
      ilen = verify(prop%name, ' ', .true.)
      write (*,900) "Device Number: "      ,num
      write (*,901) "Device Name: "        ,prop%name(1:ilen)
      write (*,903) "Total Global Memory: ",real(prop%totalGlobalMem)/1e9," Gbytes"
      write (*,902) "sharedMemPerBlock: "  ,prop%sharedMemPerBlock," bytes"
      write (*,900) "regsPerBlock: "       ,prop%regsPerBlock
      write (*,900) "warpSize: "           ,prop%warpSize
      write (*,900) "maxThreadsPerBlock: " ,prop%maxThreadsPerBlock
      write (*,904) "maxThreadsDim: "      ,prop%maxThreadsDim
      write (*,904) "maxGridSize: "        ,prop%maxGridSize
      write (*,903) "ClockRate: "          ,real(prop%clockRate)/1e6," GHz"
      write (*,902) "Total Const Memory: " ,prop%totalConstMem," bytes"
      write (*,905) "Compute Capability Revision: ",prop%major,prop%minor
      write (*,902) "TextureAlignment: "   ,prop%textureAlignment," bytes"
      write (*,906) "deviceOverlap: "      ,prop%deviceOverlap
      write (*,900) "multiProcessorCount: ",prop%multiProcessorCount
      write (*,906) "integrated: "         ,prop%integrated
      write (*,906) "canMapHostMemory: "   ,prop%canMapHostMemory
      write (*,906) "ECCEnabled: "         ,prop%ECCEnabled
      write (*,906) "UnifiedAddressing: "  ,prop%unifiedAddressing
      write (*,900) "L2 Cache Size: "      ,prop%l2CacheSize
      write (*,900) "maxThreadsPerSMP: "   ,prop%maxThreadsPerMultiProcessor
900   format (a,i0)
901   format (a,a)
902   format (a,i0,a)
903   format (a,f7.3,a)
904   format (a,2(i0,1x,'x',1x),i0)
905   format (a,i0,'.',i0)
906   format (a,l0)
      return
   end subroutine printDeviceProperties

   subroutine printDevPropShort(prop, num)
      use cudafor
      type(cudadeviceprop) :: prop
      integer num, ilen
      ilen = verify(prop%name, ' ', .true.)
      write (*,900) "-Running on Device Number: "      ,num
      write (*,901) "-Device Name: "        ,prop%name(1:ilen)
      write (*,903) "-Total Global Memory: ",real(prop%totalGlobalMem)/1e9," Gbytes"
      write (*,905) "-Compute Capability Revision: ",prop%major,prop%minor
      write (*,900) "-multiProcessorCount: ",prop%multiProcessorCount
      write (*,900) "-maxThreadsPerSMP: "   ,prop%maxThreadsPerMultiProcessor
      write (*,"(80('_')/)")
900   format (a,i0)
901   format (a,a)
902   format (a,i0,a)
903   format (a,f7.3,a)
904   format (a,2(i0,1x,'x',1x),i0)
905   format (a,i0,'.',i0)
906   format (a,l0)
      return
   end subroutine printDevPropShort





   function gptime(stopEvent, startEvent)
      type(cudaEvent), intent(IN) :: startEvent, stopEvent
      integer :: istat
      real :: time, gptime
      istat = cudaEventRecord(stopEvent, 0)
      istat = cudaEventSynchronize(stopEvent)
      istat = cudaEventElapsedTime(time, startEvent, stopEvent)
      gptime = time/1000.0
   end function gptime

   function outer_product(A,B) result(AB)
      real(myprec), intent(in) :: A(:),B(:)
      real(myprec), dimension(size(A),size(B)) :: AB
      integer :: nA,nB
      nA=size(A)
      nB=size(B)
      AB = spread(source = A, dim = 2, ncopies = nB) * &
           spread(source = B, dim = 1, ncopies = nA)
    end function outer_product

   function vector_product(a, b) result(vv)
      use mod_precision
      real(myprec), dimension(:), intent(in) :: a, b
      real(myprec), dimension(size(a)) :: vv
      vv(1) = a(2)*b(3) - a(3)*b(2)
      vv(2) = -a(1)*b(3) + a(3)*b(1)
      vv(3) = a(1)*b(2) - a(2)*b(1)
   end function vector_product

   subroutine transfer_cpu_gpu(ndim)
      implicit none
      integer, intent(in) :: ndim

      ! side2 = (side/2)**2
      sidel_d(:) = sidel(:)
      r_d(1:ndim, 1:Nmol) = r(1:ndim, 1:Nmol)
      fk_d(:) = fk(:)
      itype_d(1:Nmol) = itype(1:Nmol)

   end subroutine transfer_cpu_gpu

   subroutine common_init(natoms, ndim, nthread, idir, units, factor, nsp)
      use mod_precision
      real(myprec), intent(in) :: factor
      integer, intent(in) :: natoms, ndim, nthread, idir, nsp
      character(*), intent(in) :: units

      nmol = natoms !! WARN, change when molecules are implemented
      natms = natoms !! WARN, assign for compatibility
      ! CUDA number of blocks
      nbcuda = Nmol/nthread
      if (nbcuda*nthread .ne. Nmol) nbcuda=nbcuda+1
      bl2 = dim3(Nmol/16, Nmol/16, 1)
      thr2 = dim3(16, 16, 1)

      ! Time unit load from netcdf, set in real type seconds units
      if (units == 'femtosecond') then
         tuniti = 1.0d-15
         tstep = factor*0.001
      else if (units == 'picosecond') then
         tuniti = 1.0d-12
         tstep = factor
         write(*,'(" *** Time units in ps: assuming metal units !!)')
      else if (units == 'lj') then
         tuniti = 1.0d-12
         tstep = factor
      else
         print *, 'ERROR: timeunit ', units, ' not implemented!: watch for corrections'
         stop
      end if

      ! Idir parameters control and set pdir
      if (idir > 0) then
         if (idir > ndim) stop(" ** Error : wrong non periodic dimension")
         pdir(idir) = .false.
      end if

      ! Allocate CPU memory
      allocate (atoms(nsp))
      allocate (ntype(nsp))
      allocate (lty(nsp))
      allocate (itype(nmol))
      allocate (ipos(nsp, nmol))
      allocate (bscat(nmol))
      allocate (masa(nmol))
      if (ex_qc) then
         allocate (qcharge(nmol))
      endif
      allocate (list(nmol))
      allocate (done(nmol))
      allocate (r(ndim, nmol))
      if (ex_vel) then
         allocate (vel(ndim, nmol))
         allocate (v_d(ndim, nmol))
      end if
      if (ex_force) then
         allocate (force(ndim, nmol))
      end if
      if (run_thermo) then
         allocate(u_p(nmol))
         ecaver = 0
      endif
      if (ex_stress) then
         allocate(stress(voigt,nmol))
         pressav = 0
      endif
      ! Allocate GPU memory
      allocate (r_d(ndim, nmol))
      allocate (itype_d(nmol))
      allocate (ntype_d(nsp))
      allocate (bsc_d(nsp))
      allocate (ipos_d(nsp, nmol))
      allocate (gdone(nmol))

      ! Init variables
      ecaver = 0.0
      cell(:, :) = 0
   end subroutine common_init

   subroutine common_clear()
      use mod_precision

      ! Clean house
      deallocate (atoms)
      deallocate (ntype)
      deallocate (lty)
      deallocate (itype)
      deallocate (ipos)
      deallocate (bscat)
      deallocate (masa)
   end subroutine common_clear

end module mod_common
