module mod_densprof
   use mod_precision
   use mod_common
   use mod_input
   use cudafor
   implicit none

contains

   subroutine prof_init()
      implicit none
      width = nint((pwallp - pwall)/(2*deltar))
      allocate (densprof(0:width, nsp), densprofi(0:width, nsp))
      allocate (densprof_d(0:width, nsp))
      if (ex_qc) then
         allocate(dqminus(0:width),dqplus(0:width),qdensprof(0:width))
         dqminus(:) = 0.0
         dqplus(:) = 0.0
         qdensprof(:) = 0.0
      endif
      densprof(:, :) = 0.0d0
      densprof_d(:, :) = 0.0d0
   end subroutine prof_init

   subroutine prof_clear()
      deallocate (densprof, densprofi)
      deallocate (densprof_d)
      if (ex_qc) then
         deallocate(qdensprof,dqminus,dqplus)
      endif
   end subroutine prof_clear

   subroutine normdenspr(nconf)
      implicit none
      integer, intent(in) :: nconf
      integer :: I
      real(myprec) :: high, low, zpos, conste
      logical :: found
      found = .false.
      i = 0
      low = pwall
      high = pwallp
      do while (.not. found)
         if (maxval(densprof(i, 1:nsp)) < 1.0e-6) then
            low = (2*i + 1)*deltar + pwall
            i = i + 1
         else
            found = .true.
         end if
      end do
      found = .false.
      i = width
      do while (.not. found)
         if (maxval(densprof(i, 1:nsp)) < 1.0e-6) then
            high = (2*i + 1)*deltar + pwall
            i = i - 1
         else
            found = .true.
         end if
      end do
      high = (pwallp + high)/2
      low = (pwall + low)/2
      write(*,"(//'   # Highest accesible constrained coordinate for fluid',f15.7,/'   # Lowest accessible constrained coordinate for fluid',f15.7)")high,low
      volumen_r = (high - low)*product(sidel, pdir)
      rdenst = natms/volumen_r
      write (*, '(/" ** Total renormalized density =",f10.6)') rdenst
      do i = 1, nsp
         write (*, '(/"     - Renormalized density per species ",i2," =",f10.6)') i, ntype(i)/volumen_r
      end do
      open (222, file='densprof.dat')
      !
      ! One dimensional rho(x) normalized such that rho_i(L/2) approximates the bulk average rho_i
      !
      write (222, '("#       r ",7x,8(8x,"rho(",i1,")":))') ((i), i=1, nsp)
      if (ex_qc) then
         open (223, file='qdens.dat')
         !
         ! One dimensional rho_c(x) normalized such that rho_c(L/2) approximates the bulk average rho_c
         !
         write (223, '("#       r ",15x,"rhoi_c",8x,"rho_+",8x,"rho_-")')
      endif
      conste = (high - low)/(Nconf*2*deltar*volumen_r)
      do i = 0, width
         zpos = (2*i + 1)*deltar + pwall
         write (222, '(10f15.7)') zpos, conste*densprof(i, 1:nsp)
         if (ex_qc) then
            write (223, '(10f15.7)') zpos, conste*qdensprof(i),conste*dqplus(i), &
               conste*dqminus(i)
         endif
      end do
      close (222)
      if (ex_qc) close(223)
   end subroutine normdenspr


   subroutine profile_comp(nthread, ndim, idir, pwall, deltar)
      !
      ! Compute density profile along non periodic dimension
      !
      implicit none
      integer, intent(in) :: nthread, ndim, idir
      real(myprec), intent(in) :: pwall, deltar
      densprof_d(:, :) = 0
      call dprof<<<nbcuda, nthread>>>(r_d, Nmol, ndim, densprof_d, width, nsp, idir, itype_d&
      &, pwall, deltar)
      densprofi(:, :) = densprof_d(:, :)
      densprof(:, :) = densprof(:, :) + real(densprofi(:, :))
      if (ex_qc) then
         call qdprof(r, Nmol, ndim, qdensprof, dqplus, dqminus, width, idir, qcharge,&
         & pwall, deltar)
      endif
   end subroutine profile_comp

   subroutine qdprof(r, Nmol, dim, qdensprof, dqplus, dqminus, width, idir, qcharge,&
   & pwall, deltar)
      integer, value, intent(IN) :: Nmol, dim, width, idir
      real(double), intent(IN) :: qcharge(Nmol)
      integer i, ind, ia
      real, value, intent(IN) :: deltar, pwall
      real, dimension(dim, Nmol), intent(IN) :: r
      real(double), intent(INOUT) :: qdensprof(width), dqplus(width), dqminus(width)
      real :: qc
      do i = 1, Nmol
         qc = qcharge(i)
         !
         ! Warning: density profile must be computed along a confined direction or using wrapped coordinates
         !
         ind = int((r(idir, i) - pwall)/(2*deltar))
         if (ind < 0 .or. ind > width) then
            print *, ' Error: density profile out of boundaries ', ind, width
            stop
         end if
         qdensprof(ind) = qdensprof(ind) +qc
         if (qc<0) then
            dqminus(ind) = dqminus(ind) +qc
         else
            dqplus(ind) = dqplus(ind)+qc
         endif
      enddo
   end subroutine qdprof

   attributes(global) subroutine dprof(r, Nmol, dim, densprof, width, nsp, idir, itype&
   &, pwall, deltar)
   integer, value, intent(IN) :: Nmol, dim, nsp, width, idir
   integer, intent(IN) :: itype(Nmol)
   integer i, ind, ia, ity
   real, dimension(3) :: rv
   real, value, intent(IN) :: deltar, pwall
   real, dimension(dim, Nmol), intent(IN) :: r
   integer, intent(INOUT) :: densprof(width, nsp)
   i = (blockidx%x - 1)*blockdim%x + threadidx%x
   if (i <= Nmol) then
      !
      ! Warning: density profile must be computed along a confined direction or using wrapped coordinates
      !
      ind = int((r(idir, i) - pwall)/(2*deltar))
      if (ind < 0 .or. ind > width) then
         print *, ' Error: density profile out of boundaries ', ind, width
         stop
      end if
      ity = itype(i)
      ia = atomicadd(densprof(ind, ity), 1)
   end if
end subroutine dprof

end module mod_densprof
