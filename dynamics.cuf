module mod_dyn
   !
   ! Module to calculate dynamics properties (MSD, velocity and stress self-correlation, 
   ! and dynamic structure factors and intermediate scattering functions, total and self)
   ! Calculations are performed simulteneously over nbuffers separated by jump configurations
   ! with time origins shifted every itlimit configurations (corresponding to tlimit ps)
   !
   use mod_precision
   use mod_common
   use cudafor
   use mod_input
   implicit none
   integer :: ndyn, count_org=0, itlimit
   integer, allocatable, dimension(:) :: origin
   integer, device, allocatable, dimension(:) :: origin_d
   integer, parameter :: nbmax = 400, nblocks = 1
   real(myprec), device, allocatable, dimension(:,:,:) :: r0_d, rt_d, v0_d, fktb_d, fsktb_d
   real(myprec), device, allocatable, dimension(:,:) :: r2tb_d, v2tb_d, poff_d, stcorr_d, p0_d
   real(myprec), device, allocatable, dimension(:) :: qw_d
   integer (kind=2), device, allocatable, dimension(:,:) :: indqw_d
   real(myprec), allocatable, dimension(:,:,:) :: r0, v0
   real(myprec),  allocatable, dimension(:,:) :: fkt, fskt, sqw, ssqw
   real(myprec),  allocatable, dimension(:) :: t, r2t, v2t, stcorr
   real(float), allocatable, dimension(:) :: w, ftv
   real(float) :: sumvel=0
contains

   subroutine dyn_init()
      if (nbuffer > nbmax) then
         write(*,'("** Error: nbuffer > ",i3,", redimension if possible !")') nbmax
         stop
      endif
      ndyn = Nconf-(nbuffer-1)*jump
      Write(*,"(' *** ',i7,' configurations for dynamic analysis: ',&
         i4,' buffers starting every ',i3,' configuration ' )")ndyn, nbuffer, jump
      if (ndyn < 10) then
         write(*,"('** Error: length of dynamics to short. Reduce number of buffers !')")
         stop
      endif
      allocate(t(ndyn),r2t(ndyn))
      allocate(r0(ndim,nmol,nbuffer))
      allocate(r0_d(ndim,nmol,nbuffer),rt_d(ndim,nmol,nbuffer),r2tb_d(ndyn,nbuffer))
      r2tb_d(:,:) = 0
      r2t(:) = 0
      if (ex_vel) then
         allocate(v0(ndim,nmol,nbuffer),v2t(ndyn))
         allocate(v0_d(ndim,nmol,nbuffer),v2tb_d(ndyn,nbuffer))
         v2tb_d(:,:) = 0
         v2t(:) = 0
         allocate(w(ndyn),ftv(ndyn))
      endif
      if (ex_stress) then
         allocate(poff_d(6,nmol),stcorr_d(ndyn,nbuffer),&
            p0_d(6,nbuffer), origin_d(nbuffer))
         allocate(stcorr(ndyn),origin(nbuffer))
      endif
      if (run_sqw) then
         allocate(fkt(nqw,ndyn),fskt(nqw,ndyn))
         allocate(sqw(ndyn,nqw),ssqw(ndyn,nqw))
         allocate(fktb_d(nqw,ndyn,nbuffer),fsktb_d(nqw,ndyn,nbuffer),qw_d(nqw))
         qw_d(:) = qw(:)
         fktb_d(:,:,:) = 0.0
         fsktb_d(:,:,:) = 0.0
         fkt(:,:) = 0.0
         fskt(:,:) = 0.0
      endif
   end  subroutine dyn_init

   subroutine dyn_clear()
      deallocate(t,r2t)
      deallocate(r0)
      deallocate(r0_d,rt_d,r2tb_d)
      if (ex_vel) then
         deallocate(v0,v2t)
         deallocate(v0_d,v2tb_d)
         deallocate(w,ftv)
      endif
      if (ex_stress) then
         deallocate(stcorr)
         deallocate(stcorr_d,poff_d,p0_d)
      end if
      if (run_sqw) then
         deallocate(fkt,fskt,sqw,ssqw)
         deallocate(fktb_d,fsktb_d)
      endif
   end subroutine dyn_clear

   subroutine rtcorr(iconf)
      integer, intent(in) :: iconf
      integer :: istat, iorg, i
      real :: time_gpu, v0(3), v(3), res
      ! store times (in ps)
      if (iconf <= ndyn) t(iconf) = nstep*tstep
      ! define buffer origins
      if (iconf==1) then
         do i=1,nbuffer
            origin(i) = (i-1)*jump + 1
         enddo
         itlimit = Nconf
      elseif (iconf==2) then
         if (tlimit<0) then
            itlimit = Nconf-(nbuffer-1)*jump
            tlimit = itlimit*(t(2)-t(1))
         else
            itlimit = nint(tlimit/(t(2)-t(1)))
         endif
         write(*,"('*** Dynamics averages using ',i5,' configurations '/)") itlimit
         if (itlimit > Nconf) then
            write(*, "(//'*** Unrecoverable error: tmax=',f8.3,'> trajectory lenght !!')")tmax
            stop
         endif
      endif
      origin_d(:) = origin(:)
      if (ex_vel) then
         v_d(1:ndim, 1:Nmol) = vel(1:ndim,1:Nmol)
      end if
      if (nmol/nblocks<1) then
         write(*,"('** Error: number of particles too small < ',i4)")nblocks
      endif
      istat = cudaEventRecord(startEvent, 0)
      ! Transfer origin positions and velocities for each buffer
      do i = 1, nbuffer
         if (iconf==origin(i)) then
            r0_d(1:ndim,1:nmol,i) = r_d(1:ndim,1:nmol)
            if (ex_vel) v0_d(1:ndim,1:nmol,i) = v_d(1:ndim,1:nmol)
         endif
      enddo
      
      call rtcal<<<nblocks,nbuffer>>>(ndim,nmol,nbuffer,ndyn,iconf,&
           jump,origin_d)
      
           if (ex_vel) call vtcal<<<nblocks,nbuffer>>>(ndim,nmol,nbuffer,ndyn,iconf,&
              jump,origin_d)
      
      if (ex_stress) then
         poff_d(1:6,1:nmol) = -stress(1:6,1:nmol)/volumen
         call st_cal<<<nblocks,nbuffer>>>(nmol,nbuffer,ndyn,iconf,&
                   jump,origin_d)
      endif

      if (run_sqw) then
         if (iconf == 1) then
            allocate(indqw_d(nqwmax,ndim))
            indqw_d(:,:) = indqw(:,:)
         endif
         call  FqtnD<<<nqwmax,nbuffer>>>(nqwmax, nqw, Nmol, ndim, itype_d,&
            ntype_d, bsc_d, fk_d, nsp, dq, ndyn, iconf, nbuffer, jump, origin_d)
      endif

      do i = 1, nbuffer
         iorg =  origin(i)
         !  Shift origin position if time limit reached for buffer i
         !  only if itlimit configurations remaining 
         if(iconf-iorg==itlimit) iorg=iconf+1
         if(origin(i) .ne. iorg .and. Nconf-iorg >= itlimit) then
            ! add up buffers when itlimit reached 
            origin(i) = iorg
            r2t(1:ndyn) = r2t(1:ndyn) + r2tb_d(1:ndyn,i)
            r2tb_d(1:ndyn,i) = 0
            if (ex_stress) then
               ! accumulate stress tensor
               stcorr(1:ndyn) = stcorr(1:ndyn) + stcorr_d(1:ndyn,i)
               stcorr_d(1:ndyn,i) = 0.0
            endif
            if (ex_vel) then
               v2t(1:ndyn) = v2t(1:ndyn) +v2tb_d(1:ndyn,i)
               v2tb_d(1:ndyn,i) = 0.0
            endif
            if (run_sqw) then
               fkt(1:nqw,1:ndyn) = fkt(1:nqw,1:ndyn)+fktb_d(1:nqw,1:ndyn,i)
               fskt(1:nqw,1:ndyn) = fskt(1:nqw,1:ndyn)+fsktb_d(1:nqw,1:ndyn,i)
               fktb_d(1:nqw,1:ndyn,i) = 0
               fsktb_d(1:nqw,1:ndyn,i) = 0 
            endif 
            count_org = count_org+1
         endif
      enddo
      time_gpu = gptime(stopEvent, startEvent)
      tdyn = tdyn + time_gpu
      call printcudaerror("rtcorr exit")
   end subroutine rtcorr

   subroutine print_rtcor()
      use fftw3
      implicit none
      integer :: i, j
      real :: fconv=4.135
      real :: sum_visc=0.0, pct, pct1
      t(1:ndyn) = t(1:ndyn)-t(1)
      write(*,"(/'** Length of dynamics ',f8.3,' ps, ',i7,' configurations, '&
      ,i4,' time origins'/)")t(ndyn),ndyn, count_org
      r2t(:) = r2t(:)/count_org
      if (ex_vel) then
         v2t(:) = v2t(:)/count_org
         call fftw1d(v2t,ftv,w,ndyn,t(2)-t(1),tmax)
      end if
      if (run_sqw) then
         !
         ! set q-dependent time window for F(q,t) transforms to tmx
         if (maxval(tmqw(:))<1.0e-6) then
            tmqw(:) = tmax
         endif
      endif
      open(55,file="dyn.dat")
      if(ex_vel) open(555,file="dynw.dat")
      if (run_sqw) then
         open(65,file='fkt.dat')
         open(66,file='fskt.dat')
         open(67,file='sqw.dat')
         do i=1, nqw
            fkt(i,1:ndyn)=fkt(i,1:ndyn)/(Nmol*count_org*nw(i))
            fskt(i,1:ndyn)=fskt(i,1:ndyn)/(Nmol*count_org*nw(i))
            call fftw1d(fkt(i,1:ndyn),sqw(1:ndyn,i),w,ndyn,t(2)-t(1),tmax)
            call fftw1d(fskt(i,1:ndyn),ssqw(1:ndyn,i),w,ndyn,t(2)-t(1),tmax)
         enddo
      endif
      if (ex_stress) then
         open(56,file="viscor.dat")
         write(56,"('#',2x,'t(ps)',9x,'P_off(t)',7x,'eta_GK(t) (bar*ps))')")
      endif
      if (ex_vel) then
         write(55,"('#',2x,'t(ps)',9x,'C_r(t)',7x'C_v(t)',10x,'w(THz)',7x,'w(meV)',12x,'Z(w)')")
         write(555,"('#',9x,'w(THz)',7x,'w(meV)',12x,'Z(w)')")
      else
         write(55,"('#',2x,'t(ps)',9x,'C_r(t)')")
      endif
      if (run_sqw) then
         write(65,'("#",2x,"t(ps)",9x,8("F(",f6.4,",t)",4x:))')qw(1:nqw)
         write(66,'("#",2x,"t(ps)",9x,8("Fs(",f6.4,",t)",4x:))')qw(1:nqw)
         write(67,"('#',2x,'w(THz)',7x,'w(meV)',5x,8('S(',f6.4,',w)    Ss(',f6.4,',w)',4x:))')")(qw(j),qw(j),j=1,nqw)
      endif
      do i = 1, ndyn
         if (ex_vel) then
            !
            ! transform from w(wavenumber) to f (frequency) in THz and meV
            !
            if (i<=itlimit) write(55,"(f10.3,8f15.5)")t(i), r2t(i),v2t(i),w(i)/(2*pi),&
                        fconv*w(i)/(2*pi),ftv(i)
            write(555,"(8f15.5)")w(i)/(2*pi),fconv*w(i)/(2*pi),ftv(i)
         else
            if(i<=itlimit) write(55,"(f10.3,8f15.5)")t(i), r2t(i)
         endif
         if (ex_stress) then
            if (i==1) then
               pct =  stcorr(i)/(6*count_org)
               write(56,"(f10.3,8f15.5)")t(i),pct,0.0
            else
               pct1 = pct
               pct =  stcorr(i)/(ndim*count_org)
               ! Integrate off-diagonal pressure tensor correlation (trapezoidal rule)
               ! Use Green-Kubo relation eta_gk = (V/NkT)*\int_0^t<pxy(t')pxy(0)>dt' in (bar*s)
               !
               sum_visc = sum_visc + (pct+pct1)*(t(i)-t(i-1))/2
               if (i<=itlimit) write(56,"(f10.3,8f15.5)")t(i),pct,(volumen/temperature/c_nktv)*sum_visc
            endif
         end if
         if (run_sqw) then
            if (i<=itlimit) then
               write(65,"(f10.3,8f15.5)")t(i),fkt(1:nqw,i)
               write(66,"(f10.3,8f15.5)")t(i),fskt(1:nqw,i)
            endif
            write(67,"(2f10.3,8f15.5)")w(i)/(2*pi),fconv*w(i)/(2*pi),(sqw(i,j),ssqw(i,j),j=1,nqw)
         endif
      end do
      close(55)
      close(65)
      close(66)
      close(67)
      close(555)
   end subroutine print_rtcor



   attributes(global) subroutine FqtnD(nqwmax, nqw, Nmol, dim, itype, ntype, &
      bsc, fk, nsp, dq, dyn, iconf, buffer, jump, origin)
   integer, intent(IN) :: itype(Nmol), ntype(nsp)
   integer, value, intent(IN) :: Nmol, dim, nsp, nqwmax, dyn, iconf,&
            nqw, buffer, jump
   integer :: ibuffer, indx
   real(kind=4), intent(IN) :: bsc(nsp)
   real(kind=4) :: rkxyz, rkxyzt, fk1, fk2, fk3, kf1, kf2, kf3, tsum, q, suma
   real(kind=8) :: sumcx, sumsx, sumcpx, sumspx, q2, bs
   real(kind=8) :: sumcxt, sumsxt, sumcpxt, sumspxt, sumself
   real(kind=4), intent(IN) :: fk(dim)
   real(kind=4), value, intent(IN) ::  dq
   integer, dimension(buffer), intent(in) :: origin

   integer :: i, j, it, kx, ky, kz, ind, ia, iorg
   logical :: found
   if (blockidx%x<=nqwmax) then
      ibuffer = threadidx%x
      iorg =  origin(ibuffer)
      indx = iconf - iorg + 1
      ! Check origin and final configuration of each averaging buffer
      if (iconf>=iorg .and. indx >= 1) then
         kx = indqw_d(blockidx%x,1)
         ky = indqw_d(blockidx%x,2)
         fk1 = fk(1)
         fk2 = fk(2)
         kf1 = kx*fk1
         kf2 = ky*fk2
         if (dim==3) then
            kz = indqw_d(blockidx%x,3)
            fk3 = fk(3)
            kf3 = kz*fk3
            q2 = kf1*kf1 + kf2*kf2 + kf3*kf3
         else
            q2 = kf1*kf1 + kf2*kf2
         endif
         sumcx = 0
         sumcxt = 0
         sumsx = 0
         sumsxt = 0
         sumself = 0
         q = sqrt(q2)
         ind = 1
         found = .false.
         do while (ind<=nqw.and. .not. found)
            if (qw_d(ind)-dq/2<q .and. qw_d(ind)+dq/2>q) then
               found = .true.
            else
               ind = ind+1
            endif
         enddo
         i = 0
         do j = 1, nsp
            sumcpx = 0
            sumspx = 0
            sumcpxt = 0
            sumspxt = 0
            bs = bsc(j)
            do it = 1, ntype(j)
               i = i + 1
               if (dim==3) then
                  rkxyz = r0_d(3, i,ibuffer)*kf3+r0_d(2, i,ibuffer)*kf2+r0_d(1, i,ibuffer)*kf1
                  rkxyzt = r_d(3, i)*kf3+r_d(2, i)*kf2+r_d(1, i)*kf1
               else
                  rkxyz = r0_d(2, i,ibuffer)*kf2+r0_d(1, i,ibuffer)*kf1
                  rkxyzt = r_d(2, i)*kf2+r_d(1, i)*kf1
               endif
               sumcpx = sumcpx + __cosf(rkxyz)
               sumspx = sumspx + __sinf(rkxyz)
               sumcpxt = sumcpxt + __cosf(rkxyzt)
               sumspxt = sumspxt + __sinf(rkxyzt)
               sumself = sumself + __cosf(rkxyzt-rkxyz)
            end do
            sumcx = sumcx + bs*sumcpx
            sumcxt = sumcxt + bs*sumcpxt
            sumsx = sumsx + bs*sumspx
            sumsxt = sumsxt + bs*sumspxt
         end do
         tsum = (sumcx*sumcxt + sumsx*sumsxt)
         ia = atomicadd(fktb_d(ind,indx,ibuffer), tsum)
         ia = atomicadd(fsktb_d(ind,indx,ibuffer), real(sumself,kind=4))
      endif
   endif
end subroutine FqtnD


attributes(global) subroutine rtcal(dim,mol,buffer,dyn,iconf,jump,origin)
integer, value, intent(IN) :: mol, dim, buffer, dyn, iconf, jump
real :: rv(3), suma
real(double) :: suma8
integer :: i, j, k, npsize, nprest, ia, indx, iorg
integer, dimension(buffer), intent(in) :: origin
i = threadidx%x
iorg = origin(i)
indx = iconf - iorg + 1
! Check origin and final configuration of each averaging buffer
if (iconf==iorg) rt_d(1:dim,1:mol,i) = r_d(1:dim,1:mol)

if (iconf>=iorg .and. indx <= dyn) then
   suma8 = 0
   npsize = mol/nblocks
   nprest = mod(mol,nblocks)
   ! Unwrap coordinates
   do k = 1, dim
      rt_d(k,1:mol,i)= r_d(k,1:mol) +sidel_d(k)&
      &  *nint((rt_d(k,1:mol,i)-r_d(k,1:mol))/sidel_d(k))
   end do
   suma8 = 0
   do j = (blockidx%x - 1)*npsize+1, blockidx%x*npsize
      rv(1:dim) = rt_d(1:dim,j,i)-r0_d(1:dim,j,i)
      suma8 = dot_product(rv,rv) + suma8
   end do
   do j = blockidx%x*npsize+1, blockidx%x*npsize+nprest
      rv(1:dim) = rt_d(1:dim,j,i)-r0_d(1:dim,j,i)
      suma8 = dot_product(rv,rv)  + suma8
   end do
   suma = suma8/mol
   if (indx <= dyn .and. i <= buffer) then
      ia = atomicadd(r2tb_d(indx,i),suma)
   endif
endif
end subroutine rtcal

attributes(global) subroutine st_cal(mol,buffer,dyn,iconf,&
   jump,origin)
integer, value, intent(IN) :: mol, dim, buffer, dyn, iconf, jump
real :: suma
real(double) :: sumaxy, sumayz, sumaxz
integer :: i, j, k, npsize, nprest, ia, indx, iorg
integer, dimension(buffer), intent(in) :: origin
i = threadidx%x
iorg = origin(i)
indx = iconf - iorg + 1
! Check origin and final configuration of each averaging buffer
if (iconf>=iorg .and. indx <= dyn) then
   npsize = mol/nblocks
   nprest = mod(mol,nblocks)
   sumaxx = sum(poff_d(1,(blockidx%x - 1)*npsize+1:blockidx%x*npsize))
   sumayy = sum(poff_d(2,(blockidx%x - 1)*npsize+1:blockidx%x*npsize))
   sumazz = sum(poff_d(3,(blockidx%x - 1)*npsize+1:blockidx%x*npsize))
   sumaxy = sum(poff_d(4,(blockidx%x - 1)*npsize+1:blockidx%x*npsize))
   sumaxz = sum(poff_d(5,(blockidx%x - 1)*npsize+1:blockidx%x*npsize))
   sumayz = sum(poff_d(6,(blockidx%x - 1)*npsize+1:blockidx%x*npsize))
   if (nprest>0) then
      sumaxx = sumaxx + sum(poff_d(1,blockidx%x*npsize+1:blockidx%x*npsize+nprest))
      sumaxy = sumayy + sum(poff_d(2,blockidx%x*npsize+1:blockidx%x*npsize+nprest))
      sumazz = sumazz + sum(poff_d(3,blockidx%x*npsize+1:blockidx%x*npsize+nprest))
      sumaxy = sumaxy + sum(poff_d(4,blockidx%x*npsize+1:blockidx%x*npsize+nprest))
      sumaxz = sumaxz + sum(poff_d(5,blockidx%x*npsize+1:blockidx%x*npsize+nprest))
      sumayz = sumaxy + sum(poff_d(6,blockidx%x*npsize+1:blockidx%x*npsize+nprest))
   end if
   if (iorg==iconf) then
      p0_d(1,i) = sumaxx
      p0_d(2,i) = sumayy
      p0_d(3,i) = sumazz
      p0_d(4,i) = sumaxy
      p0_d(5,i) = sumaxz
      p0_d(6,i) = sumayz
   end if
   suma = (sumaxx*p0_d(1,i)+sumayy*p0_d(2,i)+sumazz*p0_d(3,i))*0.75 +&
          sumaxy*p0_d(4,i)+sumaxz*p0_d(5,i)+sumayz*p0_d(6,i)
   ia = atomicadd(stcorr_d(indx,i),suma)

endif
end subroutine st_cal

attributes(global) subroutine vtcal(dim,mol,buffer,dyn,iconf,jump,origin)
integer, value, intent(IN) :: mol, dim, buffer, dyn, iconf, jump
real(double) :: suma8
real :: sumf
integer :: i, j, k, npsize, nprest, ia, indx, iorg
integer, dimension(buffer), intent(in) :: origin
i = threadidx%x
iorg = origin(i)
indx = iconf - iorg + 1
! Check origin and final configuration of each averaging buffer
if (iconf>=iorg .and. indx >= 1) then
   npsize = mol/nblocks
   nprest = mod(mol,nblocks)
   suma8 = 0.0d0
   do j = (blockidx%x - 1)*npsize+1, blockidx%x*npsize
      suma8 = dot_product(v_d(1:dim,j),v0_d(1:dim,j,i)) + suma8
   end do
   do j = blockidx%x*npsize+1, blockidx%x*npsize+nprest
      suma8 = dot_product(v_d(1:dim,j),v0_d(1:dim,j,i)) + suma8
   end do
   sumf = suma8/mol
   ia = atomicadd(v2tb_d(indx,i),sumf)
endif
end subroutine vtcal



attributes(global) subroutine rtcal_org(dim,mol,buffer,dyn,iconf,jump)
integer, value, intent(IN) :: mol, dim, buffer, dyn, iconf, jump
real :: rv(3), suma
real(double) :: suma8
integer :: i, j, k, npsize, nprest, ia, indx, iorg
i = threadidx%x
iorg = (i-1)*jump+1
indx = iconf - iorg + 1
! Check origin and final configuration of each averaging buffer
if (iconf==iorg) rt_d(1:dim,1:mol,i) = r_d(1:dim,1:mol)

if (iconf>=iorg .and. indx <= dyn) then
   suma8 = 0
   npsize = mol/nblocks
   nprest = mod(mol,nblocks)
   ! Unwrap coordinates
   do k = 1, dim
      rt_d(k,1:mol,i)= r_d(k,1:mol) +sidel_d(k)&
      &  *nint((rt_d(k,1:mol,i)-r_d(k,1:mol))/sidel_d(k))
   end do
   suma8 = 0
   do j = (blockidx%x - 1)*npsize+1, blockidx%x*npsize
      rv(1:dim) = rt_d(1:dim,j,i)-r0_d(1:dim,j,i)
      suma8 = dot_product(rv,rv) + suma8
   end do
   do j = blockidx%x*npsize+1, blockidx%x*npsize+nprest
      rv(1:dim) = rt_d(1:dim,j,i)-r0_d(1:dim,j,i)
      suma8 = dot_product(rv,rv)  + suma8
   end do
   suma = suma8/mol
   if (indx <= dyn .and. i <= buffer) then
      ia = atomicadd(r2tb_d(indx,i),suma)
   endif
endif
end subroutine rtcal_org



attributes(global) subroutine vtcal_org(dim,mol,buffer,dyn,iconf,jump)
integer, value, intent(IN) :: mol, dim, buffer, dyn, iconf, jump
real(double) :: suma8
real :: sumf
integer :: i, j, k, npsize, nprest, ia, indx, iorg
i = threadidx%x
iorg = (i-1)*jump+1
indx = iconf - iorg + 1
! Check origin and final configuration of each averaging buffer
if (iconf>=iorg .and. indx >= 1) then
   npsize = mol/nblocks
   nprest = mod(mol,nblocks)
   suma8 = 0.0d0
   do j = (blockidx%x - 1)*npsize+1, blockidx%x*npsize
      suma8 = dot_product(v_d(1:dim,j),v0_d(1:dim,j,i)) + suma8
   end do
   do j = blockidx%x*npsize+1, blockidx%x*npsize+nprest
      suma8 = dot_product(v_d(1:dim,j),v0_d(1:dim,j,i)) + suma8
   end do
   sumf = suma8/mol
   ia = atomicadd(v2tb_d(indx,i),sumf)
endif
end subroutine vtcal_org

end module mod_dyn
