module mod_dyn
   use mod_precision
   use mod_common
   use cudafor
   use mod_input 
   implicit none
   integer :: ndyn
   integer, parameter :: nbmax = 100, nblocks = 1
   real(myprec), device, allocatable, dimension(:,:,:) :: r0_d, rt_d, v0_d
   real(myprec), device, allocatable, dimension(:,:) :: r2tb_d, v2tb_d
   real(myprec), allocatable, dimension(:,:,:) :: r0, v0
   real(myprec),  allocatable, dimension(:,:) :: r2tb, v2tb
   real(myprec),  allocatable, dimension(:) :: t, r2t, v2t 
   contains

   subroutine dyn_init()
      if (nbuffer > nbmax) then
         write(*,'("** Error: nbuffer > ",i3,", redimension if possible !")') nbmax
         stop
      endif
      ndyn = Nconf - Nbuffer
      if (ndyn < 10) then
         write(*,"('** Error: length of dynamics to short. Reduce number of buffers !')")
         stop
      endif 
      allocate(t(ndyn),r2t(ndyn))
      allocate(r0(ndim,nmol,nbuffer),r2tb(ndyn,nbuffer))
      allocate(r0_d(ndim,nmol,nbuffer),rt_d(ndim,nmol,nbuffer),r2tb_d(ndyn,nbuffer))
      if (keytrj > 0) then
         allocate(v0(ndim,nmol,nbuffer),v2t(ndyn),v2tb(ndyn,nbuffer))
         allocate(v0_d(ndim,nmol,nbuffer),v2tb_d(ndyn,nbuffer))
      endif
   end  subroutine dyn_init

   subroutine dyn_clear()
      deallocate(t,r2t)
      deallocate(r0,r2tb)
      deallocate(r0_d,rt_d,r2tb_d)
      if (keytrj > 0) then
         deallocate(v0,v2t,v2tb)
         deallocate(v0_d,v2tb_d)
      endif
   end subroutine dyn_clear
   
   subroutine rtcorr(iconf)
      integer, intent(in) :: iconf
      integer :: i
      integer :: istat
      real :: time_gpu, v0(3), v(3)
      if (nmol/nblocks<1) then
         write(*,"('** Error: number of particles too small < ',i4)")nblocks
      endif 
      if (iconf <= nbuffer) then
         r0_d(1:ndim,1:nmol,iconf) = r_d(1:ndim,1:nmol)
         r2tb_d(1:ndim,iconf) = 0
         if (keytrj>0) then
            v0_d(1:ndim,1:nmol,iconf) = v_d(1:ndim,1:nmol)
            v2tb_d(1:ndyn,iconf) = 0
         end if

      endif
      t(iconf) = nstep*tstep
      istat = cudaEventRecord(startEvent, 0)
      call rtcal<<<nblocks,nbuffer>>>(ndim,nmol,nbuffer,ndyn,iconf)
      if (keytrj>0) then
         call vtcal<<<nblocks,nbuffer>>>(ndim,nmol,nbuffer,ndyn,iconf)
      end if 
      time_gpu = gptime(stopEvent, startEvent)
      tdyn = tdyn + time_gpu
   end subroutine rtcorr

   subroutine print_rtcor()
      implicit none
      integer :: i
      r2tb(1:ndyn,1:nbuffer) = r2tb_d(1:ndyn,1:nbuffer)
      r2t(1:ndyn) = sum(r2tb(1:ndyn,1:nbuffer),DIM=2)
      if (keytrj>0) then
         v2tb(1:ndyn,1:nbuffer) = v2tb_d(1:ndyn,1:nbuffer)
         v2t(1:ndyn) = sum(v2tb(1:ndyn,1:nbuffer),DIM=2)
      end if 
      t(1:ndyn) = t(1:ndyn)-t(1)
      open(55,file="dyn.dat")
      do i = 1, ndyn
         write(55,"(f8.3,8f15.5)")t(i), r2t(i)/nbuffer,v2t(i)/(nbuffer)
      end do
      close(55)
   end subroutine print_rtcor



   attributes(global) subroutine vtcal(dim,mol,buffer,dyn,iconf)
   integer, value, intent(IN) :: mol, dim, buffer, dyn, iconf
   real :: v(3), v0(3), suma
   integer :: i, j, k, npsize, nprest, ia
   i = threadidx%x
   if (iconf-i+1>dyn) return
   npsize = mol/nblocks
   nprest = mod(mol,nblocks)
   if (iconf>=i) then
      suma = 0
      do j = (blockidx%x - 1)*npsize+1, blockidx%x*npsize
         v0(1:dim) = v0_d(1:dim,j,i)
         v(1:dim) = v_d(1:dim,j)
         suma = dot_product(v,v0) + suma 
      end do
      do j = blockidx%x*npsize+1, blockidx%x*npsize+nprest
         v0(1:dim) = v0_d(1:dim,j,i)
         v(1:dim) = v_d(1:dim,j)
         suma = dot_product(v,v0) + suma 
      end do
  !    print *,  iconf-i+1,i, dyn, buffer, suma/mol 
      ia = atomicadd(v2tb_d(iconf-i+1,i),suma/mol)
   endif 
end subroutine vtcal
   
   attributes(global) subroutine vrtcal(dim,mol,buffer,dyn,iconf)
      integer, value, intent(IN) :: mol, dim, buffer, dyn, iconf
      real :: rv(3), v(3), v0(3), suma, sumav
      integer :: i, j, k, npsize, nprest, ia
      i = threadidx%x
      if (iconf-i+1>dyn) return
      npsize = mol/nblocks
      nprest = mod(mol,nblocks)
 !     if (i==1) print *, i, 'iconf=',iconf, npsize, nprest, blockidx%x
      if (i==iconf) then
         rt_d(1:dim,1:mol,i) = r_d(1:dim,1:mol)
         r2tb_d(1,i) = 0.0
      end if
      if (iconf>i) then
         ! Unwrap coordinates
         do k = 1, dim
            rt_d(k,1:mol,i)= r_d(k,1:mol) +sidel_d(k)&
                             & *nint((rt_d(k,1:mol,i)-r_d(k,1:mol))/sidel_d(k))
         end do
         suma = 0
         sumav = 0
         do j = (blockidx%x - 1)*npsize+1, blockidx%x*npsize
            rv(1:dim) = rt_d(1:dim,j,i)-r0_d(1:dim,j,i)
            v0(1:dim) = v0_d(1:dim,j,i)
            v(1:dim) = v_d(1:dim,j)
            sumav = dot_product(v,v0) + sumav 
            suma = dot_product(rv,rv) + suma 
         end do
         do j = blockidx%x*npsize+1, blockidx%x*npsize+nprest
            rv(1:dim) = rt_d(1:dim,j,i)-r0_d(1:dim,j,i)
            v0(1:dim) = v0_d(1:dim,j,i)
            v(1:dim) = v_d(1:dim,j)
            sumav = dot_product(v,v0) + sumav 
            suma = dot_product(rv,rv)  + suma
         end do
         ia = atomicadd(r2tb_d(iconf-i+1,i),suma/mol)
         ia = atomicadd(v2tb_d(iconf-i+1,i),sumav/mol)
      endif 
   end subroutine vrtcal

   attributes(global) subroutine rtcal(dim,mol,buffer,dyn,iconf)
   integer, value, intent(IN) :: mol, dim, buffer, dyn, iconf
   real :: rv(3), suma
   integer :: i, j, k, npsize, nprest, ia
   i = threadidx%x
   if (iconf-i+1>dyn) return
   npsize = mol/nblocks
   nprest = mod(mol,nblocks)
!     if (i==1) print *, i, 'iconf=',iconf, npsize, nprest, blockidx%x
   if (i==iconf) then
      rt_d(1:dim,1:mol,i) = r_d(1:dim,1:mol)
      r2tb_d(1,i) = 0.0
   end if
   if (iconf>i) then
      ! Unwrap coordinates
      do k = 1, dim
         rt_d(k,1:mol,i)= r_d(k,1:mol) +sidel_d(k)&
                          & *nint((rt_d(k,1:mol,i)-r_d(k,1:mol))/sidel_d(k))
      end do
      suma = 0
      do j = (blockidx%x - 1)*npsize+1, blockidx%x*npsize
         rv(1:dim) = rt_d(1:dim,j,i)-r0_d(1:dim,j,i)
         suma = dot_product(rv,rv)/mol + suma 
      end do
      do j = blockidx%x*npsize+1, blockidx%x*npsize+nprest
         rv(1:dim) = rt_d(1:dim,j,i)-r0_d(1:dim,j,i)
         suma = dot_product(rv,rv)/mol  + suma
      end do
      ia = atomicadd(r2tb_d(iconf-i+1,i),suma)
   endif 
end subroutine rtcal
end module mod_dyn
