module mod_order
! Module for order parameter calculations
    use mod_precision
    use mod_common, only: r_d, sidel_d, cellxd, cellyd, cellzd, maxjd, maxkd, nnd, headd, listad, neighd, gptime, startEvent, stopEvent, tord
    use mod_input, only: norder, orderp, nthread
    use cudafor
    implicit none
    real(myprec), allocatable :: atomic_order_cos(:,:), atomic_order_sin(:,:), &
    avorder_cos(:), avorder_sin(:), avorder(:)
    real(myprec), device, allocatable :: atomic_order_cos_d(:,:), atomic_order_sin_d(:,:)
    integer, parameter :: nmax_order = 20
    integer, constant :: orderp_d(nmax_order)
contains
    subroutine order_init(norder,nmol)
        integer, intent(in) :: norder, nmol
        if (norder > nmax_order) then
            write(*,'("*** Error: norder exceeds maximum allowed value of ",i0)') nmax_order
        else
            orderp_d(1:norder) = orderp(1:norder)
        end if
        if (.not. allocated(atomic_order_cos)) then
            allocate(atomic_order_cos(nmol, norder))
            allocate(avorder_cos(norder))
            allocate(avorder_sin(norder))
            allocate(avorder(norder))
            avorder_cos(:) = 0.0
            avorder_sin(:) = 0.0
            avorder(:) = 0.0
            atomic_order_cos(:,:) = 0.0
            allocate(atomic_order_sin(nmol, norder))
            atomic_order_sin(:,:) = 0.0
            allocate(atomic_order_cos_d(nmol, norder), atomic_order_sin_d(nmol, norder))
            atomic_order_cos_d(:,:) = 0.0
            atomic_order_sin_d(:,:) = 0.0
        endif

    end subroutine order_init

    subroutine order_clear()
        if (allocated(orderp)) deallocate(orderp)
        if (allocated(atomic_order_cos)) deallocate(atomic_order_cos)
        if (allocated(atomic_order_sin)) deallocate(atomic_order_sin)
        if (allocated(atomic_order_cos_d)) deallocate(atomic_order_cos_d)
        if (allocated(atomic_order_sin_d)) deallocate(atomic_order_sin_d)
    end subroutine order_clear

    subroutine compute_order(Nmol, dim, rcl, sidel)
        integer, intent(in) :: Nmol, dim
        real(myprec), intent(in) :: sidel(dim), rcl
        real(myprec) :: rcl2, time_gpu, sumac
        integer :: istat,i
        !
        ! Compute order parameter
        !
        if (norder > 0) then
            rcl2 = rcl*rcl
            
            istat = cudaEventRecord(startEvent, 0)
            ! Launch GPU kernel
            atomic_order_cos_d(:,:) = 0.0
            atomic_order_sin_d(:,:) = 0.0
            call gpu_comp_order<<<Nmol/nthread+1, nthread>>>(r_d, Nmol, dim, norder, rcl2, sidel_d)
            time_gpu = gptime(stopEvent, startEvent)
            tord = tord + time_gpu  
            atomic_order_cos(:,:) = atomic_order_cos_d(:,:)
            atomic_order_sin(:,:) = atomic_order_sin_d(:,:)
            avorder_cos(1:norder) = sum(atomic_order_cos(1:nmol,1:norder), dim=1)/Nmol
            avorder_sin(1:norder) = sum(atomic_order_sin(1:Nmol,1:norder), dim=1)/Nmol
            avorder(1:norder)=avorder(1:norder)+sqrt(avorder_cos(:)**2+avorder_sin(:)**2)
        end if
    end subroutine compute_order

    attributes(global) subroutine gpu_comp_order(r, Nmol, dim, norder, rcl2, sidel)
        integer, value, intent(IN) :: Nmol, dim, norder
        real(myprec), value :: rcl2
        real(myprec), intent(IN) :: r(dim, Nmol), sidel(dim)
        real(myprec)  :: rv(3), rr2, s0, s1, s2, c0, c1, c2, cx, sy, cz, d
        integer :: i, j, counter, ncount, ix, jy, kz, cell, icell
        i = (blockidx%x - 1)*blockdim%x + threadidx%x
        if (i <= Nmol) then
            ncount = 0
            !
            ! Locate cell
            !
            ix = int((r(1, i))/cellxd)
            jy = int((r(2, i))/cellyd)
            if (dim == 3) then
                kz = int((r(3, i))/cellzd)
                cell = (ix*maxjd + jy)*maxkd + kz
            else
                cell = (ix*maxjd + jy)
            end if
            !
            ! Loop over neighbouring cells
            !
            do icell = 1, nnd
                j = headd(neighd(cell, icell))
                do while (j .ne. 0)
                    if (j .ne. i) then
                        rv(1:dim) = r(1:dim, i) - r(1:dim, j)
                        rv = rv - sidel*nint(rv/sidel)
                        rr2 = Dot_product(rv, rv)
                        if (rr2 < rcl2) then
                            ncount = ncount + 1
                        ! compute per atom order parameter
                            d = __fsqrt_rn(rr2)
                            cx = rv(1)/d
                            sy = rv(2)/d
                            if (dim == 3) then  
                                cz = rv(3)/d
                            end if
                            c0 = 1.0
                            c1 = cx
                            s0 = 0.0
                            s1 = sy
                            counter = 1
                            do ix = 2, orderp_d(norder)
                                c2 = c1*cx-s1*sy
                                s2 = s1*cx+c1*sy
                                s0 = s1
                                s1 = s2
                                c0 = c1
                                c1 = c2
                                ! add contribution to order parameter
                                if (ix == orderp_d(counter)) then
                                    atomic_order_cos_d(i, counter) = atomic_order_cos_d(i, counter) + c2
                                    atomic_order_sin_d(i, counter) = atomic_order_sin_d(i, counter) + s2
                                    counter = counter + 1
                                end if
                            end do
                        end if
                    end if
                    j = listad(j)
                end do
            end do
            if (ncount > 0) then
                atomic_order_cos_d(i, 1:norder) = atomic_order_cos_d(i, 1:norder)/real(ncount, myprec)
                atomic_order_sin_d(i, 1:norder) = atomic_order_sin_d(i, 1:norder)/real(ncount, myprec)
            end if
        end if
    end subroutine gpu_comp_order 
end module mod_order    