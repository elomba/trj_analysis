module mod_order
    ! Module for order parameter calculationso
    ! Added 3D order parameter calculation
    use mod_precision
    use mod_common, only: r_d, r, sidel_d, cellxd, cellyd, cellzd, maxjd, maxkd, nnd, headd, listad, neighd, gptime, startEvent, stopEvent, tord, side2, ndrclus, drclus
    use mod_input, only: norder, orderp, nnbond, nthread, run_clusters, rclcl, deltar, minclsize, use_cell, ndim 
    use mod_clusters, only: cluster, avcluster_order, avcluster_order_cos, avcluster_order_sin, &
    cluster_order_cos, cluster_order_sin, maxcln, rclxyz, nbigcl
    use cudafor
    implicit none
    real(myprec) :: rclcl2
    real(myprec), allocatable :: atomic_order_cos(:,:), atomic_order_sin(:,:), atomic_ql(:,:),&
        avorder_cos(:), avorder_sin(:), avorder(:)
    real(myprec), allocatable :: rhoorder(:,:), ordercum(:,:), rhoorderav(:,:), ordercumav(:,:)
    real(myprec), device, allocatable :: atomic_order_cos_d(:,:), atomic_order_sin_d(:,:), &
        atomic_ql_d(:,:)
    real(myprec), dimension(:,:), allocatable :: pref
    real(myprec), device, dimension(:,:), allocatable :: yll,  prefd
    real(myprec), device, dimension(:), allocatable :: cosmphi, sinmphi
    integer, parameter :: nmax_order = 20
    integer, constant :: orderp_d(nmax_order)
contains
    function fact(x) result(res)
    integer :: x, y
    real(myprec) :: res
    y = x
    res = 1.0
    do while (y>0)
        res = res*y 
        y=y-1
    end do
    end function fact

    subroutine order_init(norder,nmol)
        integer, intent(in) :: norder, nmol
        integer :: lmax
        lmax = orderp(norder)
        if (norder > nmax_order) then
            write(*,'("*** Error: norder exceeds maximum allowed value of ",i0)') nmax_order
        else
            orderp_d(1:norder) = orderp(1:norder)
        end if
        if (.not. allocated(atomic_order_cos)) then
            allocate(atomic_order_cos(nmol, norder))
            allocate(avorder_cos(norder))
            allocate(avorder_sin(norder))
            allocate(avorder(norder))
            avorder_cos(:) = 0.0
            avorder_sin(:) = 0.0
            avorder(:) = 0.0
            atomic_order_cos(:,:) = 0.0
            allocate(atomic_order_sin(nmol, norder))
            atomic_order_sin(:,:) = 0.0
            allocate(atomic_order_cos_d(nmol, norder), atomic_order_sin_d(nmol, norder))
            atomic_order_cos_d(:,:) = 0.0
            atomic_order_sin_d(:,:) = 0.0
            if (ndim == 3) then
                allocate(yll(0:lmax, 0:lmax))
                allocate(pref(0:lmax, 0:lmax))
                allocate(cosmphi(0:lmax))
                allocate(sinmphi(0:lmax))
                yll(:,:) = 0.0
                pref(:,:) = 0.0
                cosmphi(:) = 0.0
                sinmphi(:) = 0.0
                allocate(prefd(0:lmax, 0:lmax))
                allocate(atomic_ql_d(nmol, norder))
                allocate(atomic_ql(nmol, norder))
                atomic_ql_d(:,:) = 0.0
                atomic_ql(:,:) = 0.0
                prefd(:,:) = 0.0
            end if  
        endif
        if (run_clusters) then
            if (.not. allocated(rhoorder)) then
                allocate(rhoorder(0:ndrclus, norder), ordercum(0:ndrclus, norder))
                allocate(rhoorderav(0:ndrclus, norder), ordercumav(0:ndrclus, norder))
                rhoorder(:,:) = 0.0
                ordercum(:,:) = 0.0
                rhoorderav(:,:) = 0.0
                ordercumav(:,:) = 0.0
            endif
        end if

    end subroutine order_init

    subroutine order_clear()
        if (allocated(orderp)) deallocate(orderp)
        if (allocated(atomic_order_cos)) deallocate(atomic_order_cos)
        if (allocated(atomic_order_sin)) deallocate(atomic_order_sin)
        if (allocated(atomic_order_cos_d)) deallocate(atomic_order_cos_d)
        if (allocated(atomic_order_sin_d)) deallocate(atomic_order_sin_d)
        if (allocated(avorder_cos)) deallocate(avorder_cos)
        if (allocated(avorder_sin)) deallocate(avorder_sin)
        if (allocated(avorder)) deallocate(avorder)
        if (allocated(rhoorder)) deallocate(rhoorder)
        if (allocated(rhoorderav)) deallocate(rhoorderav)  
        if (allocated(ordercum)) deallocate(ordercum)
        if (allocated(ordercumav)) deallocate(ordercumav)
        if (ndim == 3) then
            if (allocated(yll)) deallocate(yll)
            if (allocated(pref)) deallocate(pref)
            if (allocated(cosmphi)) deallocate(cosmphi)
            if (allocated(sinmphi)) deallocate(sinmphi)
            if (allocated(prefd)) deallocate(prefd)
            if (allocated(atomic_ql_d)) deallocate(atomic_ql_d)
            if (allocated(atomic_ql)) deallocate(atomic_ql)
        end if  
    end subroutine order_clear

    subroutine compute_order(Nmol, dim, rcl, sidel)
        integer, intent(in) :: Nmol, dim
        real(myprec), intent(in) :: sidel(dim), rcl
        real(myprec) :: rcl2, time_gpu, sumac
        integer :: istat,i, lmax
        !
        ! Compute order parameter
        !
        if (norder > 0) then
            lmax = orderp(norder)
            rcl2 = rcl*rcl

            
            istat = cudaEventRecord(startEvent, 0)
            ! Launch GPU kernel
            atomic_order_cos_d(:,:) = 0.0
            atomic_order_sin_d(:,:) = 0.0
            if (dim == 2) then
                if (use_cell) then
                    call gpu_comp_order2D<<<Nmol/nthread+1, nthread,8*norder+1>>>(r_d, Nmol, dim, norder, nnbond, rcl2, sidel_d)
                else
                    ! If not using cell list, use a different kernel without cell list
                    print *, '** Warnning: calculating order parameter without cell list'
                    call gpu_comp_order_nc<<<Nmol/nthread+1, nthread,8*norder+1>>>(r_d, Nmol, dim, norder, nnbond, rcl2, sidel_d)
                end if
                if (run_clusters) Then
                    cluster_order_cos(:,:) = 0.0
                    cluster_order_sin(:,:) = 0.0
                    if (rclcl > 0.0) then
                        rclcl2 = rclcl*rclcl
                        call cl_comp_order2D(rclxyz(1:dim, 1:maxcln), nbigcl, dim, norder, nnbond, rclcl2, sidel)
                    end if
                end if
            else
                call prefactors(lmax,pref)
                prefd(:,:) = pref(:,:)
                if (use_cell) then
                    call gpu_comp_order3D<<<Nmol/nthread+1, nthread,8*norder+1>>>(r_d, Nmol, dim, norder, nnbond, rcl2, sidel_d)
                else
                    ! If not using cell list, use a different kernel without cell list
                    print *, '** Warnning: calculating order parameter without cell list'
                    call gpu_comp_order3D_nc<<<Nmol/nthread+1, nthread,8*norder+1>>>(r_d, Nmol, dim, norder, nnbond, rcl2, sidel_d)
                end if
            end if
            time_gpu = gptime(stopEvent, startEvent)
            tord = tord + time_gpu
            if (ndim==2) then  
                atomic_order_cos(:,:) = atomic_order_cos_d(:,:)
                atomic_order_sin(:,:) = atomic_order_sin_d(:,:)
                avorder_cos(1:norder) = sum(atomic_order_cos(1:nmol,1:norder), dim=1)/Nmol
                avorder_sin(1:norder) = sum(atomic_order_sin(1:Nmol,1:norder), dim=1)/Nmol
                avorder(1:norder)=avorder(1:norder)+sqrt(avorder_cos(:)**2+avorder_sin(:)**2)
            else
                atomic_ql(:,:) = atomic_ql_d(:,:)
                do i=1,10
                    write(*,'(" Q_l for atom ",i3,": ",10f12.5)') i, atomic_ql(i,1:norder)
                end do
                avorder(1:norder) = avorder(1:norder) + sum(atomic_ql(1:Nmol,1:norder), dim=1)/Nmol
            end if  
            if (run_clusters) then
                if (ndim==2) then  
                    avcluster_order_cos(1:norder) = sum(cluster_order_cos(1:nbigcl,1:norder), dim=1)/nbigcl
                    avcluster_order_sin(1:norder) = sum(cluster_order_sin(1:nbigcl,1:norder), dim=1)/nbigcl
                    avcluster_order(1:norder)=avcluster_order(1:norder)+sqrt(avcluster_order_cos(:)**2+avcluster_order_sin(:)**2)
                    rhoorder(:,:) = 0.0
                    do i = 1, maxcln
                        if (cluster(i)%clsize >= minclsize) then
                            call clorderprof(r, dim, nbigcl, cluster(i)%members(:),&
                            cluster(i)%clsize, sidel, rhoorder, ordercum, ndrclus, drclus, &
                            &  cluster(i)%center(1:dim))
                        endif
                    enddo
                    rhoorderav(:,:) = rhoorderav(:,:)+rhoorder(:,:)/real(nbigcl, myprec)
                    ordercumav(:,:) = ordercumav(:,:)+ordercum(:,:)/real(nbigcl, myprec)
                else
                    ! 3D cluster order parameter calculation can be added here
                end if
            end if  
        end if
    end subroutine compute_order

    attributes(global) subroutine gpu_comp_order2D(r, Nmol, dim, norder, nnbnd, rcl2, sidel)
        integer, value, intent(IN) :: Nmol, dim, norder, nnbnd
        real(myprec), value :: rcl2
        real(myprec), intent(IN) :: r(dim, Nmol), sidel(dim)
        real(myprec)  :: rv(3), rr2, s0, s1, s2, c0, c1, c2, cx, sy, cz, d
        real(myprec) :: cosd(norder), sind(norder)
        integer :: i, j, counter, ncount, ix, jy, kz, cell, icell
        i = (blockidx%x - 1)*blockdim%x + threadidx%x
        if (i <= Nmol) then
            cosd(:) = 0.0
            sind(:) = 0.0
            ncount = 0
            !
            ! Locate cell
            !
            ix = int((r(1, i))/cellxd)
            jy = int((r(2, i))/cellyd)
            cell = (ix*maxjd + jy)
            !
            ! Loop over neighbouring cells
            !
            do icell = 1, nnd
                j = headd(neighd(cell, icell))
                do while (j .ne. 0)
                    if (j .ne. i) then
                        rv(1:dim) = r(1:dim, i) - r(1:dim, j)
                        rv = rv - sidel*nint(rv/sidel)
                        rr2 = Dot_product(rv, rv)
                        if (rr2 < rcl2) then
                            ncount = ncount + 1
                        ! count neighbors within cutoff and
                        ! compute per atom order parameter
                            d = __fsqrt_rn(rr2)
                            cx = rv(1)/d
                            sy = rv(2)/d
                            if (dim == 3) then  
                                cz = rv(3)/d
                            end if
                            c0 = 1.0
                            c1 = cx
                            s0 = 0.0
                            s1 = sy
                            counter = 1
                            do ix = 2, orderp_d(norder)
                                ! iterate to comnute sin(m*theta) and cos(m*theta)  
                                c2 = c1*cx-s1*sy
                                s2 = s1*cx+c1*sy
                                s0 = s1
                                s1 = s2
                                c0 = c1
                                c1 = c2
                                ! add contribution to order parameter
                                if (ix == orderp_d(counter)) then
                                    cosd(counter) = cosd(counter) + c2
                                    sind(counter) = sind(counter) + s2
                                    counter = counter + 1
                                end if
                            end do
                        end if
                    end if
                    j = listad(j)
                end do
            end do
            if (ncount > 0) then
                if (nnbnd ==0) then
                    atomic_order_cos_d(i, 1:norder) = cosd(1:norder)/real(ncount, myprec)
                    atomic_order_sin_d(i, 1:norder) = sind(1:norder)/real(ncount, myprec)
                else
                    ! Only compute order parameter if number of neighbors 
                    ! equals the order of the parameter
                    do j=1, norder
                        if (orderp_d(j) == ncount) then
                            atomic_order_cos_d(i, j) = cosd(j)/real(ncount, myprec)
                            atomic_order_sin_d(i, j) = sind(j)/real(ncount, myprec)
                        end if
                    end do
                end if
            end if
        end if
    end subroutine gpu_comp_order2D

   

    subroutine prefactors(lmax,pref)
    implicit none
    real(myprec), parameter :: pi=3.141592653589793
    integer, intent(IN) :: lmax
    real(myprec), intent(INOUT) :: pref(0:lmax,0:lmax)
    real(myprec) :: fact
    integer :: l, m
    pref(:,:) = 0
    print *, 'lmax=',lmax
    do l=0, lmax
        do m=0, l
            pref(l,m) = sqrt((2*l+1)/(4*pi)*fact(l-m)/fact(l+m))
        enddo
        write(*,*) 'Prefactors for l=',l,': ', (pref(l,m), m=0,l)
    enddo
    end subroutine prefactors

    
    attributes(global) subroutine gpu_comp_order3D(r, Nmol, dim, norder, nnbnd, rcl2, sidel)
        integer, value, intent(IN) :: Nmol, dim, norder, nnbnd
        real(myprec), value :: rcl2
        real(myprec), intent(IN) :: r(dim, Nmol), sidel(dim)
        real(myprec)  :: rv(3), rr2, s0, s1, s2, c0, c1, c2, cx, sy, cy, d, d2
        real(myprec) :: cosd(norder), sind(norder)
        integer :: i, j, counter, ncount, ix, jy, kz, cell, icell, lmax, m
        i = (blockidx%x - 1)*blockdim%x + threadidx%x
        if (i <= Nmol) then
            lmax = orderp_d(norder)
            cosd(:) = 0.0
            sind(:) = 0.0
            ncount = 0
            !
            ! Locate cell
            !
            ix = int((r(1, i))/cellxd)
            jy = int((r(2, i))/cellyd)
            kz = int((r(3, i))/cellzd)
            cell = (ix*maxjd + jy)*maxkd + kz
            !
            ! Loop over neighbouring cells
            !
            do icell = 1, nnd
                j = headd(neighd(cell, icell))
                do while (j .ne. 0)
                    if (j .ne. i) then
                        rv(1:dim) = r(1:dim, i) - r(1:dim, j)
                        rv = rv - sidel*nint(rv/sidel)
                        rr2 = Dot_product(rv, rv)
                        if (rr2 < rcl2) then
                            ncount = ncount + 1
                        ! count neighbors within cutoff and
                        ! compute per atom order parameter
                            d = __fsqrt_rn(rr2)
                            cx = rv(3)/d
                            d2 = __fsqrt_rn(rv(1)*rv(1) + rv(2)*rv(2))
                            if (d2 < 1.0e-12_myprec) then
                                sy = 0.0_myprec
                                cy = 1.0_myprec
                            else    
                                sy = rv(2)/d2
                                cy = rv(1)/d2
                            endif
                            call ysph(cx, sy, cy, lmax)
                            if (i==1) then
                                print *,  j, ncount, cx, sy,cy
                                print *, ' Y_lm for l=',2,': ', yll(2,0),yll(2,1),yll(2,2) 
                                print *, ' cosmphi: ', cosmphi(0),cosmphi(1),cosmphi(2)
                                print *, ' sinmphi: ', sinmphi(0),sinmphi(1),sinmphi(2)
                            end if
                            counter = 1
                            do ix = 2, lmax
                                c2= yll(ix,0)*cosmphi(0)
                                s2= yll(ix,0)*sinmphi(0)
                                do m = 1, ix
                                    c2 = c2+2*yll(ix,m)*cosmphi(m)
                                    s2 = s2+2*yll(ix,m)*sinmphi(m)
                                end do
                                ! add contribution to order parameter
                                ! iterate to compute Q_lm
                                if (ix == orderp_d(counter)) then
                                    cosd(counter) = cosd(counter) + c2
                                    sind(counter) = sind(counter) + s2
                                    counter = counter + 1
                                end if
                            end do
                        end if
                    end if
                    j = listad(j)
                end do
            end do
            if (ncount > 0) then
                if (nnbnd ==0) then
                    do j=1, norder
                        atomic_ql_d(i, j) = __fsqrt_rn((cosd(j)/real(ncount, myprec))**2+&
                    (sind(j)/real(ncount, myprec))**2)
                    end do
                else
                    ! Only compute order parameter if number of neighbors 
                    ! equals the order of the parameter
                    do j=1, norder
                        if (orderp_d(j) == ncount) then
                            atomic_ql_d(i, j) = __fsqrt_rn((cosd(j)/real(ncount, myprec))**2+&
                    (sind(j)/real(ncount, myprec))**2)
                        end if
                    end do
                end if
            end if
        end if
    end subroutine gpu_comp_order3D

    attributes(device) subroutine ysph(x,y,z,lmax)
    implicit none
    real(myprec), intent(IN) :: x, y, z
    integer, intent(IN) :: lmax
    real(myprec) :: cx, sy, c0, s0, c1, s1, c2, s2
    integer :: l, m
    !
    ! Iterate to compute cos(m*phi) and sin(m*phi) with y=cos(phi), z= sin(phi)
    call plm(x,lmax,yll)
    cosmphi(0) = 1.0
    cosmphi(1) = y
    sinmphi(0) = 0.0
    sinmphi(1) = z
    cx = y
    sy = z
    c0 = 1.0
    c1 = cx
    s0 = 0.0
    s1 = sy
    do m = 2, lmax
        ! iterate to compute sin(m*theta) and cos(m*theta)  
        c2 = c1*cx-s1*sy
        s2 = s1*cx+c1*sy
        s0 = s1
        s1 = s2
        c0 = c1
        c1 = c2
        cosmphi(m) = c2
        sinmphi(m) = s2
    end do
    print *, ' cosmphi: ', lmax, y,z, cosmphi(0), cosmphi(1),cosmphi(2)
    print *, ' sinmphi: ', lmax, y,z, sinmphi(0), sinmphi(1),sinmphi(2)
    !
    yll(:,:) = yll(:,:)*prefd(:,:)
    end subroutine ysph



    attributes(device) subroutine plm(x,l,p)
        real(myprec), intent(IN) :: x
        integer, intent(IN) :: l
        real(myprec), dimension(0:l,0:l) :: p
        integer :: mmax, m, i
        real(myprec) :: pmm, pmmp1, pll
        !
        ! Compute associated Legendre polynomial P_l^m(x) using recursion
        !
        mmax = l
        if (abs(x) > 1.0) then
            p(:,:) = 0.0
            return
        end if
        do m = 0, mmax
           pmm = 1.0
            if (m == 0) then
                p(0,0) = 1.0
             else
                do i = 1, m
                   pmm = pmm * (-sqrt(1.0 - x*x)) * (2*i - 1)
                   p(m,m) = pmm
                end do
             endif
             pmmp1 = x * (2*m + 1) * p(m,m)
             p(m+1,m) = pmmp1
             do i = m + 2, l
                pll = ((2*i - 1)*x*pmmp1 - (i + m - 1)*pmm)/(i - m)
                pmm = pmmp1
                pmmp1 = pll
                p(i,m) = pll
             end do
          end do
      end subroutine plm


    attributes(global) subroutine gpu_comp_order_nc(r, Nmol, dim, norder, nnbnd, rcl2, sidel)
        integer, value, intent(IN) :: Nmol, dim, norder, nnbnd
        real(myprec), value :: rcl2
        real(myprec), intent(IN) :: r(dim, Nmol), sidel(dim)
        real(myprec)  :: rv(3), rr2, s0, s1, s2, c0, c1, c2, cx, sy, cz, d
        real(myprec) :: cosd(norder), sind(norder)
        integer :: i, j, counter, ncount, lmax, ix
        i = (blockidx%x - 1)*blockdim%x + threadidx%x
        if (i <= Nmol) then
            lmax = orderp_d(norder)
            cosd(:) = 0.0
            sind(:) = 0.0
            ncount = 0
            do j = 1, Nmol 
                    if (j .ne. i) then
                        rv(1:dim) = r(1:dim, i) - r(1:dim, j)
                        rv = rv - sidel*nint(rv/sidel)
                        rr2 = Dot_product(rv, rv)
                        if (rr2 < rcl2) then
                            ncount = ncount + 1
                        ! count neighbors within cutoff and
                        ! compute per atom order parameter
                            d = __fsqrt_rn(rr2)
                            cx = rv(1)/d
                            sy = rv(2)/d
                            if (dim == 3) then  
                                cz = rv(3)/d
                            end if
                            c0 = 1.0
                            c1 = cx
                            s0 = 0.0
                            s1 = sy
                            counter = 1
                            do ix = 2, lmax
                                ! iterate to compute sin(m*theta) and cos(m*theta)  
                                c2 = c1*cx-s1*sy
                                s2 = s1*cx+c1*sy
                                s0 = s1
                                s1 = s2
                                c0 = c1
                                c1 = c2
                                ! add contribution to order parameter
                                if (ix == orderp_d(counter)) then
                                    cosd(counter) = cosd(counter) + c2
                                    sind(counter) = sind(counter) + s2
                                    counter = counter + 1
                                end if
                            end do
                        end if
                    endif
            end do
            if (ncount > 0) then
                if (nnbnd ==0) then
                    atomic_order_cos_d(i, 1:norder) = cosd(1:norder)/real(ncount, myprec)
                    atomic_order_sin_d(i, 1:norder) = sind(1:norder)/real(ncount, myprec)
                else
                    ! Only compute order parameter if number of neighbors 
                    ! equals the order of the parameter
                    do j=1, norder
                        if (orderp_d(j) == ncount) then
                            atomic_order_cos_d(i, j) = cosd(j)/real(ncount, myprec)
                            atomic_order_sin_d(i, j) = sind(j)/real(ncount, myprec)
                        end if
                    end do
                end if
            end if
        end if
    end subroutine gpu_comp_order_nc

       attributes(global) subroutine gpu_comp_order3D_nc(r, Nmol, dim, norder, nnbnd, rcl2, sidel)
        integer, value, intent(IN) :: Nmol, dim, norder, nnbnd
        real(myprec), value :: rcl2
        real(myprec), intent(IN) :: r(dim, Nmol), sidel(dim)
        real(myprec)  :: rv(3), rr2, s0, s1, s2, c0, c1, c2, cx, cy, sy, d, d2
        real(myprec) :: cosd(norder), sind(norder)
        integer :: i, j, counter, ncount, lmax, ix, m
        i = (blockidx%x - 1)*blockdim%x + threadidx%x
        if (i <= Nmol) then
            lmax = orderp_d(norder)
            cosd(:) = 0.0
            sind(:) = 0.0
            ncount = 0
            do j = 1, Nmol
                    if (j .ne. i) then
                        rv(1:dim) = r(1:dim, i) - r(1:dim, j)
                        rv = rv - sidel*nint(rv/sidel)
                        rr2 = Dot_product(rv, rv)
                        if (rr2 < rcl2) then
                            ncount = ncount + 1
                        ! count neighbors within cutoff and
                        ! compute per atom order parameter
                            d = __fsqrt_rn(rr2)
                            cx = rv(3)/d
                            d2 = __fsqrt_rn(rv(2)*rv(2) + rv(3)*rv(3))
                            if (d2 < 1.0e-12_myprec) then
                                sy = 0.0_myprec
                                cy = 1.0_myprec
                            else    
                                sy = rv(2)/d2
                                cy = rv(1)/d2
                            endif
                            call ysph(cx, sy, cy, lmax)
                            counter = 1
                            do ix = 2, lmax
                                c2= yll(ix,0)*cosmphi(0)
                                s2= yll(ix,0)*sinmphi(0)
                                do m = 1, ix
                                    c2 = c2+2*yll(ix,m)*cosmphi(m)
                                    s2 = s2+2*yll(ix,m)*sinmphi(m)
                                end do
                                ! add contribution to order parameter
                                ! iterate to compute Q_lm
                                if (ix == orderp_d(counter)) then
                                    cosd(counter) = cosd(counter) + c2
                                    sind(counter) = sind(counter) + s2
                                    counter = counter + 1
                                end if
                            end do
                        end if
                    end if
            end do
            if (ncount > 0) then
                if (nnbnd ==0) then
                    do j=1, norder
                        atomic_ql_d(i, j) = __fsqrt_rn((cosd(j)/real(ncount, myprec))**2+&
                    (sind(j)/real(ncount, myprec))**2)
                    end do
                else
                    ! Only compute order parameter if number of neighbors 
                    ! equals the order of the parameter
                    do j=1, norder
                        if (orderp_d(j) == ncount) then
                            atomic_ql_d(i, j) = __fsqrt_rn((cosd(j)/real(ncount, myprec))**2+&
                    (sind(j)/real(ncount, myprec))**2)
                        end if
                    end do
                end if
            end if
        end if
    end subroutine gpu_comp_order3D_nc


    subroutine cl_comp_order2D(r, Nmol, dim, norder, nnbnd, rcl2, sidel)
        integer, intent(IN) :: Nmol, dim, norder, nnbnd
        real(myprec), value :: rcl2
        real(myprec), intent(IN) :: r(dim, Nmol), sidel(dim)
        real(myprec)  :: rv(3), rr2, s0, s1, s2, c0, c1, c2, cx, sy, cz, d
        real(myprec) :: cosd(norder), sind(norder)
        integer :: i, j, counter, ncount, ix, jy, kz, cell, icell
        do i = 1, Nmol
            cosd(:) = 0.0
            sind(:) = 0.0
            ncount = 0
            ncount = 0
            do j = 1, Nmol
                if (j.ne.i) then
                    rv(1:dim) = r(1:dim, i) - r(1:dim, j)
                    rv = rv - sidel*nint(rv/sidel)
                    rr2 = Dot_product(rv, rv)
                    if (rr2 < rcl2) then
                        ncount = ncount + 1
                        ! count neighbors within cutoff and
                        ! compute per atom order parameter
                        d = sqrt(rr2)
                        cx = rv(1)/d
                        sy = rv(2)/d
                        c0 = 1.0
                        c1 = cx
                        s0 = 0.0
                        s1 = sy
                        counter = 1
                        do ix = 2, orderp(norder)
                            ! iterate to comnute sin(m*theta) and cos(m*theta)  
                            c2 = c1*cx-s1*sy
                            s2 = s1*cx+c1*sy
                            s0 = s1
                            s1 = s2
                            c0 = c1
                            c1 = c2
                            ! add contribution to order parameter
                            if (ix == orderp(counter)) then
                                cosd(counter) = cosd(counter) + c2
                                sind(counter) = sind(counter) + s2
                                counter = counter + 1
                            end if
                        end do
                    end if
                end if
            end do
            if (ncount > 0) then
                if (nnbnd ==0) then
                    cluster_order_cos(i, 1:norder) = cosd(1:norder)/real(ncount, myprec)
                    cluster_order_sin(i, 1:norder) = sind(1:norder)/real(ncount, myprec)
                else
                    !
                    ! Only compute order parameter if number of neighbors 
                    ! equals the order of the parameter
                    do j=1, norder
                        if (orderp(j) == ncount) then
                            cluster_order_cos(i, j) = cosd(j)/real(ncount, myprec)
                            cluster_order_sin(i, j) = sind(j)/real(ncount, myprec)
                        end if
                    end do
                 end if
            end if
        end do

    end subroutine cl_comp_order2D

    subroutine clorderprof(r,dim, nmol, members, nm, sidel, rhoorder, ordercum, lsmax, deltar, center)
      integer, intent(IN) :: nm, lsmax, dim, nmol
      integer, intent(IN) :: members(nm)
      real, intent(IN) :: r(dim, Nmol), sidel(dim), center(dim), deltar
      real, intent(INOUT) :: rhoorder(0:lsmax, norder)
      real, intent(INOUT) :: ordercum(0:lsmax, norder)
      real :: rv(3), rr2, rr, fact
      integer :: count(0:lsmax), cumcount(0:lsmax)
      integer :: k, l, i, j, ind
      ! order(r) is normalized for each configuration,
      ! since particle number may change
      ! Order parameters are averaged over each slice
      ! and then over configurations
      count(:) = 0
      cumcount(:) = 0
      do k = 1, nm
         i = members(k)
         rv(1:dim) = r(1:dim, i) - center(1:dim)
         ! PBC (unwrap if necessary)
         rv(1:dim) = rv(1:dim) - sidel(1:dim)*nint(rv(1:dim)/sidel(1:dim))
         rr2 = Dot_product(rv(1:dim), rv(1:dim))
         rr = sqrt(rr2)
         ind = int(rr/deltar)
         if (ind <= lsmax) then
            count(ind) = count(ind) + 1
             do j = 1, norder
                rhoorder(ind,j) = rhoorder(ind,j) + sqrt(atomic_order_cos(i,j)**2 + atomic_order_sin(i,j)**2)
             end do
         end If
      end do
      do i = 0, lsmax
        do j = 1, norder
            ordercum(i,j) = sum(rhoorder(0:i,j))
            cumcount(i) = sum(count(0:i))
            if (cumcount(i) > 0) then
                ordercum(i,j) = ordercum(i,j)/real(cumcount(i), myprec)
            end if
        end do
        if (count(i) > 0) then
            fact = 1.0/real(count(i), myprec)
            do j = 1, norder
                rhoorder(i,j) = rhoorder(i,j)*fact
            end do
        end if
     end do    
   end subroutine clorderprof   
end module mod_order    