module mod_order
! Module for order parameter calculations
    use mod_precision
    use mod_common, only: r_d, r, sidel_d, cellxd, cellyd, cellzd, maxjd, maxkd, nnd, headd, listad, neighd, gptime, startEvent, stopEvent, tord, side2, ndrclus, drclus
    use mod_input, only: norder, orderp, nnbond, nthread, run_clusters, rclcl, deltar, minclsize 
    use mod_clusters, only: cluster, avcluster_order, avcluster_order_cos, avcluster_order_sin, &
    cluster_order_cos, cluster_order_sin, maxcln, rclxyz, nbigcl
    use cudafor
    implicit none
    real(myprec) :: rclcl2
    real(myprec), allocatable :: atomic_order_cos(:,:), atomic_order_sin(:,:), &
        avorder_cos(:), avorder_sin(:), avorder(:)
    real(myprec), allocatable :: rhoorder(:,:), rhoorderav(:,:)
    real(myprec), device, allocatable :: atomic_order_cos_d(:,:), atomic_order_sin_d(:,:)
    integer, parameter :: nmax_order = 20
    integer, constant :: orderp_d(nmax_order)
contains
    subroutine order_init(norder,nmol)
        integer, intent(in) :: norder, nmol
        if (norder > nmax_order) then
            write(*,'("*** Error: norder exceeds maximum allowed value of ",i0)') nmax_order
        else
            orderp_d(1:norder) = orderp(1:norder)
        end if
        if (.not. allocated(atomic_order_cos)) then
            allocate(atomic_order_cos(nmol, norder))
            allocate(avorder_cos(norder))
            allocate(avorder_sin(norder))
            allocate(avorder(norder))
            avorder_cos(:) = 0.0
            avorder_sin(:) = 0.0
            avorder(:) = 0.0
            atomic_order_cos(:,:) = 0.0
            allocate(atomic_order_sin(nmol, norder))
            atomic_order_sin(:,:) = 0.0
            allocate(atomic_order_cos_d(nmol, norder), atomic_order_sin_d(nmol, norder))
            atomic_order_cos_d(:,:) = 0.0
            atomic_order_sin_d(:,:) = 0.0
         
        endif
        if (run_clusters) then
            if (.not. allocated(rhoorder)) then
                allocate(rhoorder(0:ndrclus, norder))
                allocate(rhoorderav(0:ndrclus, norder))
                rhoorder(:,:) = 0.0
                rhoorderav(:,:) = 0.0
            endif
        end if

    end subroutine order_init

    subroutine order_clear()
        if (allocated(orderp)) deallocate(orderp)
        if (allocated(atomic_order_cos)) deallocate(atomic_order_cos)
        if (allocated(atomic_order_sin)) deallocate(atomic_order_sin)
        if (allocated(atomic_order_cos_d)) deallocate(atomic_order_cos_d)
        if (allocated(atomic_order_sin_d)) deallocate(atomic_order_sin_d)
        if (allocated(avorder_cos)) deallocate(avorder_cos)
        if (allocated(avorder_sin)) deallocate(avorder_sin)
        if (allocated(avorder)) deallocate(avorder)
        if (allocated(rhoorder)) deallocate(rhoorder)
        if (allocated(rhoorderav)) deallocate(rhoorderav)   
    end subroutine order_clear

    subroutine compute_order(Nmol, dim, rcl, sidel)
        integer, intent(in) :: Nmol, dim
        real(myprec), intent(in) :: sidel(dim), rcl
        real(myprec) :: rcl2, time_gpu, sumac
        integer :: istat,i
        !
        ! Compute order parameter
        !
        if (norder > 0) then
            rcl2 = rcl*rcl
            
            istat = cudaEventRecord(startEvent, 0)
            ! Launch GPU kernel
            atomic_order_cos_d(:,:) = 0.0
            atomic_order_sin_d(:,:) = 0.0
            if (dim == 2) then
                call gpu_comp_order<<<Nmol/nthread+1, nthread,8*norder+1>>>(r_d, Nmol, dim, norder, nnbond, rcl2, sidel_d)
                if (run_clusters) Then
                    cluster_order_cos(:,:) = 0.0
                    cluster_order_sin(:,:) = 0.0
                    if (rclcl > 0.0) then
                        rclcl2 = rclcl*rclcl
                        call cl_comp_order(rclxyz(1:dim, 1:maxcln), nbigcl, dim, norder, nnbond, rclcl2, sidel)
                    end if
                end if
            else
                print *, 'Error: only 2D systems are implemented for order parameter calculation'
                stop
            end if
            time_gpu = gptime(stopEvent, startEvent)
            tord = tord + time_gpu  
            atomic_order_cos(:,:) = atomic_order_cos_d(:,:)
            atomic_order_sin(:,:) = atomic_order_sin_d(:,:)
            avorder_cos(1:norder) = sum(atomic_order_cos(1:nmol,1:norder), dim=1)/Nmol
            avorder_sin(1:norder) = sum(atomic_order_sin(1:Nmol,1:norder), dim=1)/Nmol
            avorder(1:norder)=avorder(1:norder)+sqrt(avorder_cos(:)**2+avorder_sin(:)**2)
            if (run_clusters) then
                avcluster_order_cos(1:norder) = sum(cluster_order_cos(1:nbigcl,1:norder), dim=1)/nbigcl
                avcluster_order_sin(1:norder) = sum(cluster_order_sin(1:nbigcl,1:norder), dim=1)/nbigcl
                avcluster_order(1:norder)=avcluster_order(1:norder)+sqrt(avcluster_order_cos(:)**2+avcluster_order_sin(:)**2)
                rhoorder(:,:) = 0.0
                do i = 1, maxcln
                    if (cluster(i)%clsize >= minclsize) then
                        call clorderprof(r, dim, nbigcl, cluster(i)%members(:),&
                        cluster(i)%clsize, sidel, rhoorder, ndrclus, drclus, &
                        &  cluster(i)%center(1:dim))
                    endif
                enddo
                rhoorderav(:,:) = rhoorderav(:,:)+rhoorder(:,:)/real(nbigcl, myprec)
            end if  
        end if
    end subroutine compute_order

    attributes(global) subroutine gpu_comp_order(r, Nmol, dim, norder, nnbnd, rcl2, sidel)
        integer, value, intent(IN) :: Nmol, dim, norder, nnbnd
        real(myprec), value :: rcl2
        real(myprec), intent(IN) :: r(dim, Nmol), sidel(dim)
        real(myprec)  :: rv(3), rr2, s0, s1, s2, c0, c1, c2, cx, sy, cz, d
        real(myprec) :: cosd(norder), sind(norder)
        integer :: i, j, counter, ncount, ix, jy, kz, cell, icell
        i = (blockidx%x - 1)*blockdim%x + threadidx%x
        if (i <= Nmol) then
            cosd(:) = 0.0
            sind(:) = 0.0
            ncount = 0
            !
            ! Locate cell
            !
            ix = int((r(1, i))/cellxd)
            jy = int((r(2, i))/cellyd)
            if (dim == 3) then
                kz = int((r(3, i))/cellzd)
                cell = (ix*maxjd + jy)*maxkd + kz
            else
                cell = (ix*maxjd + jy)
            end if
            !
            ! Loop over neighbouring cells
            !
            do icell = 1, nnd
                j = headd(neighd(cell, icell))
                do while (j .ne. 0)
                    if (j .ne. i) then
                        rv(1:dim) = r(1:dim, i) - r(1:dim, j)
                        rv = rv - sidel*nint(rv/sidel)
                        rr2 = Dot_product(rv, rv)
                        if (rr2 < rcl2) then
                            ncount = ncount + 1
                        ! count neighbors within cutoff and
                        ! compute per atom order parameter
                            d = __fsqrt_rn(rr2)
                            cx = rv(1)/d
                            sy = rv(2)/d
                            if (dim == 3) then  
                                cz = rv(3)/d
                            end if
                            c0 = 1.0
                            c1 = cx
                            s0 = 0.0
                            s1 = sy
                            counter = 1
                            do ix = 2, orderp_d(norder)
                                ! iterate to comnute sin(m*theta) and cos(m*theta)  
                                c2 = c1*cx-s1*sy
                                s2 = s1*cx+c1*sy
                                s0 = s1
                                s1 = s2
                                c0 = c1
                                c1 = c2
                                ! add contribution to order parameter
                                if (ix == orderp_d(counter)) then
                                    cosd(counter) = cosd(counter) + c2
                                    sind(counter) = sind(counter) + s2
                                    counter = counter + 1
                                end if
                            end do
                        end if
                    end if
                    j = listad(j)
                end do
            end do
            if (ncount > 0) then
                if (nnbnd ==0) then
                    atomic_order_cos_d(i, 1:norder) = cosd(1:norder)/real(ncount, myprec)
                    atomic_order_sin_d(i, 1:norder) = sind(1:norder)/real(ncount, myprec)
                else
                    ! Only compute order parameter if number of neighbors 
                    ! equals the order of the parameter
                    do j=1, norder
                        if (orderp_d(j) == ncount) then
                            atomic_order_cos_d(i, j) = cosd(j)/real(ncount, myprec)
                            atomic_order_sin_d(i, j) = sind(j)/real(ncount, myprec)
                        end if
                    end do
                end if
            end if
        end if
    end subroutine gpu_comp_order 

    subroutine cl_comp_order(r, Nmol, dim, norder, nnbnd, rcl2, sidel)
        integer, intent(IN) :: Nmol, dim, norder, nnbnd
        real(myprec), value :: rcl2
        real(myprec), intent(IN) :: r(dim, Nmol), sidel(dim)
        real(myprec)  :: rv(3), rr2, s0, s1, s2, c0, c1, c2, cx, sy, cz, d
        real(myprec) :: cosd(norder), sind(norder)
        integer :: i, j, counter, ncount, ix, jy, kz, cell, icell
        do i = 1, Nmol
            cosd(:) = 0.0
            sind(:) = 0.0
            ncount = 0
            ncount = 0
            do j = 1, Nmol
                if (j.ne.i) then
                    rv(1:dim) = r(1:dim, i) - r(1:dim, j)
                    rv = rv - sidel*nint(rv/sidel)
                    rr2 = Dot_product(rv, rv)
                    if (rr2 < rcl2) then
                        ncount = ncount + 1
                        ! count neighbors within cutoff and
                        ! compute per atom order parameter
                        d = sqrt(rr2)
                        cx = rv(1)/d
                        sy = rv(2)/d
                        c0 = 1.0
                        c1 = cx
                        s0 = 0.0
                        s1 = sy
                        counter = 1
                        do ix = 2, orderp(norder)
                            ! iterate to comnute sin(m*theta) and cos(m*theta)  
                            c2 = c1*cx-s1*sy
                            s2 = s1*cx+c1*sy
                            s0 = s1
                            s1 = s2
                            c0 = c1
                            c1 = c2
                            ! add contribution to order parameter
                            if (ix == orderp(counter)) then
                                cosd(counter) = cosd(counter) + c2
                                sind(counter) = sind(counter) + s2
                                counter = counter + 1
                            end if
                        end do
                    end if
                end if
            end do
            if (ncount > 0) then
                if (nnbnd ==0) then
                    cluster_order_cos(i, 1:norder) = cosd(1:norder)/real(ncount, myprec)
                    cluster_order_sin(i, 1:norder) = sind(1:norder)/real(ncount, myprec)
                else
                    !
                    ! Only compute order parameter if number of neighbors 
                    ! equals the order of the parameter
                    do j=1, norder
                        if (orderp(j) == ncount) then
                            cluster_order_cos(i, j) = cosd(j)/real(ncount, myprec)
                            cluster_order_sin(i, j) = sind(j)/real(ncount, myprec)
                        end if
                    end do
                 end if
            end if
        end do

    end subroutine cl_comp_order 

    subroutine clorderprof(r,dim, nmol, members, nm, sidel, rhoorder, lsmax, deltar, center)
      integer, intent(IN) :: nm, lsmax, dim, nmol
      integer, intent(IN) :: members(nm)
      real, intent(IN) :: r(dim, Nmol), sidel(dim), center(dim), deltar
      real, intent(INOUT) :: rhoorder(0:lsmax, norder)
      real :: rv(3), rr2, rr, fact
      integer :: count(0:lsmax)
      integer :: k, l, i, j, ind
      ! order(r) is normalized for each configuration,
      ! since particle number may change
      ! Order parameters are averaged over each slice
      ! and then over configurations
      count(:) = 0
      do k = 1, nm
         i = members(k)
         rv(1:dim) = r(1:dim, i) - center(1:dim)
         ! PBC (unwrap if necessary)
         rv(1:dim) = rv(1:dim) - sidel(1:dim)*nint(rv(1:dim)/sidel(1:dim))
         rr2 = Dot_product(rv(1:dim), rv(1:dim))
         rr = sqrt(rr2)
         ind = int(rr/deltar)
         if (ind <= lsmax) then
            count(ind) = count(ind) + 1
             do j = 1, norder
                rhoorder(ind,j) = rhoorder(ind,j) + sqrt(atomic_order_cos(i,j)**2 + atomic_order_sin(i,j)**2)
             end do
         end If
      end do
      do i = 0, lsmax
         if (count(i) > 0) then
            fact = 1.0/real(count(i), myprec)
            do j = 1, norder
               rhoorder(i,j) = rhoorder(i,j)*fact
            end do
         end if
      end do    
   end subroutine clorderprof   
end module mod_order    