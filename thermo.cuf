module mod_thermo
   use mod_precision
   use mod_common
   use mod_input
   use cudafor
   implicit none
   real(myprec), allocatable, dimension(:) :: rc2pot
   real(myprec), device, allocatable, dimension(:) :: rc2pot_d
   real(myprec), allocatable, dimension(:, :, :) :: rr2_pot
   real(myprec), device, allocatable, dimension(:, :, :) :: rr2_pot_d
   integer :: npots
   real(myprec) :: dr2pot
   real(myprec), allocatable, dimension(:) :: eng
   real(myprec), device, allocatable, dimension(:) :: eng_d

contains

   subroutine thermo_init()
      ! integer, intent(in) :: nbcuda
      integer :: io_input_file, i, j, k, junkint, nitid = 1
      character(len=128) :: filename, junkchar
      real(double) :: junkreal, potd
      real(myprec) :: test_prec = 0.0, rr

      allocate (rc2pot(nit))
      allocate (rc2pot_d(nit))
      rc2pot(:) = 1.0e-7

      allocate (eng(nbcuda))
      allocate (eng_d(nbcuda))

      do i = 1, nit - 1
         do j = i, nit - 1
            write (filename, "(A1,2I1,A4)") 'u', i, j, '.dat'
            open (newunit=io_input_file, file=filename, action='read')
            do k = 1, 4
               read (io_input_file, *)
            end do
            read (io_input_file, *) junkchar, npots, junkchar, junkreal, junkint
            read (io_input_file, *)
            if (.not. allocated(rr2_pot)) then
               allocate (rr2_pot(0:npots, 2, nit))
               allocate (rr2_pot_d(0:npots, 2, nit))
            end if
            do k = 0, npots - 1
               read (io_input_file, *) junkint, rr, potd, junkreal
               if (potd >= huge(test_prec)) then
                  rr2_pot(k, 2, nitid) = huge(test_prec)
               else
                  rr2_pot(k, 2, nitid) = potd
               end if
               rr2_pot(k, 1, nitid) = rr*rr
            end do
            nitid = nitid + 1
            close (io_input_file)
         end do
      end do
      do i = 1, nit
         do j = npots - 1, 1, -1
            if (rr2_pot(j, 2, i) > rc2pot(i)) then
               rc2pot(i) = rr2_pot(j, 1, i)
               exit
            end if
         end do
      end do
      rc2pot_d(:) = rc2pot(:)
      rr2_pot_d(:, :, :) = rr2_pot(:, :, :)
      dr2pot = rr2_pot(3, 1, 1) - rr2_pot(2, 1, 1)
   end subroutine thermo_init

   subroutine poteng(natoms, nbcuda, nthread)
      !
      ! Main call to compute potential energy and move data back and forth from device
      !
      implicit none
      integer, intent(IN) :: natoms, nbcuda, nthread
      integer :: istart, i, ind, k, l, istat
      real :: time_gpu

      istat = cudaEventRecord(startEvent, 0)
      if (ndim == 3) then
         call poteng3d<<<nbcuda, nthread>>>(natoms, nsp, dr2pot)
      else
         call poteng2d<<<nbcuda, nthread>>>(Nmol, nsp, dr2pot)
      end if
      eng(:) = eng_d(:)
      time_gpu = gptime(stopEvent, startEvent)
      epot = sum(eng)/2.0
      tpoteng = tpoteng + time_gpu

   end subroutine poteng

   attributes(global) subroutine poteng3d(natoms, nsp, dr2pot)
      !
      ! Massively parallel potential energy calculation
      !
      integer, value, intent(IN) :: natoms, nsp
      real, value, intent(in) :: dr2pot
      integer i, j, ind, ia, fact, iti, itj, istart, ij, ir
      real(myprec) :: rr2, xi, yi, zi, xd, yd, zd, mu, mu2, xmu
      real(myprec) :: y0, y1, y2, y3, a0, a1, a2, a3
      real(double), shared, dimension(blockdim%x) :: energ

      i = (blockidx%x - 1)*blockdim%x + threadidx%x
      energ(threadidx%x) = 0.0
      if (i <= natoms) then
         iti = itype_d(i)
         xi = r_d(1, i)
         yi = r_d(2, i)
         zi = r_d(3, i)
         do j = 1, natoms
            if (i /= j) then
               itj = itype_d(j)
               ij = rdf_fij(iti, itj, nsp)
               xd = r_d(1, j) - xi
               yd = r_d(2, j) - yi
               zd = r_d(3, j) - zi
               xd = xd - sidel_d(1)*nint(xd/sidel_d(1))
               yd = yd - sidel_d(2)*nint(yd/sidel_d(2))
               zd = zd - sidel_d(3)*nint(zd/sidel_d(3))
               rr2 = xd*xd + yd*yd + zd*zd
               If (rr2 .Lt. rc2pot_d(ij)) Then
                  xmu = rr2/dr2pot
                  ir = int(xmu)
                  mu = xmu - ir
                  mu2 = mu*mu
                  y0 = rr2_pot_d(ir - 1, 2, ij)
                  y1 = rr2_pot_d(ir, 2, ij)
                  y2 = rr2_pot_d(ir + 1, 2, ij)
                  y3 = rr2_pot_d(ir + 2, 2, ij)
                  a0 = -0.5d0*y0 + 1.5d0*y1 - 1.5d0*y2 + 0.5d0*y3
                  a1 = y0 - 2.5d0*y1 + 2*y2 - 0.5d0*y3
                  a2 = -0.5d0*y0 + 0.5d0*y2
                  a3 = y1
                  energ(threadidx%x) = energ(threadidx%x) + a0*mu*mu2 + a1*mu2 + a2*mu + a3
               end if
            end if
         end do
      end if
      call syncthreads()
      if (threadidx%x == 1) eng_d(blockidx%x) = sum(energ(:))

   end subroutine poteng3d

   attributes(global) subroutine poteng2d(Nmol, nsp, dr2pot)
      !
      ! Massively parallel potential energy calculation
      !
      integer, value, intent(IN) :: Nmol, nsp
      real, value, intent(in) :: dr2pot
      integer i, j, ind, ia, fact, iti, itj, istart, ij, ir
      real ::  rr2, xi, yi, zi, xd, yd, zd, mu, mu2, xmu, y0, y1, y2, y3, a0, a1, a2, a3
      real(double) :: eng0 = 0.0

      i = (blockidx%x - 1)*blockdim%x + threadidx%x

   end subroutine poteng2d

   subroutine thermo_clear()
      deallocate (rc2pot)
      deallocate (rc2pot_d)
      deallocate (rr2_pot)
      deallocate (rr2_pot_d)
      deallocate (eng)
      deallocate (eng_d)
   end subroutine thermo_clear

   attributes(device) integer function rdf_fij(i, j, nsp)
      implicit none
      integer, value :: i, j, nsp
      !
      ! this function maps the indices (i,j) of a symmetric matrix A(i,j) onto the single index k
      ! of a vector
      !
      if (i <= j) then
         rdf_fij = (i - 1)*(nsp - 1) - (i - 1)*(i - 2)/2 + j
      else
         rdf_fij = (j - 1)*(nsp - 1) - (j - 1)*(j - 2)/2 + i
      end if
   end function rdf_fij

end module mod_thermo
