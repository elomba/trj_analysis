module mod_thermo
   use mod_precision
   use mod_common
   use mod_input
   use cudafor
   use cellp_props
   implicit none
   real(myprec), allocatable, dimension(:, :) :: rr2table
   real(myprec), allocatable, dimension(:) :: rc2pot
   real(myprec), device, allocatable, dimension(:) :: rc2pot_d
   real(myprec), allocatable, dimension(:, :) :: pottable
   real(myprec), device, allocatable, dimension(:, :) :: pottable_d
   integer :: npots
   real(myprec) :: dr2pot
   real(double), allocatable, dimension(:) :: eng
   real(double), device, allocatable, dimension(:) :: eng_d

contains

   subroutine thermo_init(natoms)
      integer, intent(in) :: natoms
      integer :: io_input_file, i, j, k, junkint, nitid = 1
      character(len=128) :: filename, junkchar
      real(double) :: junkreal, potd
      real(myprec) :: test_prec = 0.0, rr

      allocate (rc2pot(nit))
      allocate (rc2pot_d(nit))
      rc2pot(:) = 1.0e-7

      allocate (eng(natoms))
      allocate (eng_d(natoms))
      do i = 1, nsp
         do j = i, nsp
            write (filename, "(A1,2I1,A4)") 'u', i, j, '.dat'
            open (newunit=io_input_file, file=filename, action='read',status='old')
            do k = 1, 4
               read (io_input_file, *)
            end do
            read (io_input_file, *) junkchar, npots, junkchar, junkreal, junkint
            read (io_input_file, *)
            if (.not. allocated(pottable)) then
               allocate (pottable(0:npots, nit))
               allocate (pottable_d(0:npots, nit))
               allocate (rr2table(0:npots, nit))
            end if
            do k = 0, npots - 1
               read (io_input_file, *) junkint, rr, potd, junkreal
               if (potd >= huge(test_prec)) then
                  pottable(k, nitid) = huge(test_prec)
               else
                  pottable(k, nitid) = potd
               end if
               rr2table(k, nitid) = rr*rr
            end do
            nitid = nitid + 1
            close (io_input_file)
         end do
      end do
      do i = 1, nit
         do j = npots - 1, 1, -1
            if (rr2table(j, i) > rc2pot(i)) then
               rc2pot(i) = rr2table(j, i)
               exit
            end if
         end do
      end do
      rc2pot_d(:) = rc2pot(:)
      ! Increase the maximum potential cutoff by 0.1A to avoid round off errors in
      ! particles being outside neighboring cells
      rclp = sqrt(maxval(rc2pot(1:nsp)))+0.1
      pottable_d(:, :) = pottable(:, :)
      dr2pot = rr2table(3, 1) - rr2table(2, 1)
   end subroutine thermo_init

   subroutine thermo_init_cluster(dim, sidel, side2, maxcln, cluster)
      integer, intent(IN) :: dim, maxcln
      real, intent(IN) :: sidel(3), side2
      type(clus), dimension(maxcln), intent(inout) :: cluster
      real :: rv(3), rr2, rr, fact
      integer :: k, kk, i, j, ind, iti, itj, ij, ir, c, d, cc, dd, jmin
      real(myprec) :: mu, mu2, xmu
      real(myprec) :: y0, y1, y2, y3, a0, a1, a2, a3
      real(double) :: engcl

      epotcl_min = 1.0e10
      epotcl_max = -1.0e10
      epotperatomcl_min = 1.0e10
      epotperatomcl_max = -1.0e10
      do c = 1, maxcln
         if (cluster(c)%clsize > minclsize) then
            engcl = 0.0
            do k = 1, cluster(c)%clsize - 1
               do kk = k + 1, cluster(c)%clsize
                  i = cluster(c)%members(k)
                  j = cluster(c)%members(kk)
                  iti = itype(i)
                  itj = itype(j)
                  ij = thermo_fij(iti, itj, nsp)
                  rv(1:dim) = r(1:dim, i) - r(1:dim, j)
                  rv(1:dim) = rv(1:dim) - sidel(1:dim)*nint(rv(1:dim)/sidel(1:dim))
                  rr2 = Dot_product(rv(1:dim), rv(1:dim))
                  If (rr2 .Lt. rc2pot(ij)) Then
                     xmu = rr2/dr2pot
                     ir = int(xmu)
                     mu = xmu - ir
                     mu2 = mu*mu
                     y0 = pottable(ir - 1, ij)
                     y1 = pottable(ir, ij)
                     y2 = pottable(ir + 1, ij)
                     y3 = pottable(ir + 2, ij)
                     a0 = -0.5d0*y0 + 1.5d0*y1 - 1.5d0*y2 + 0.5d0*y3
                     a1 = y0 - 2.5d0*y1 + 2*y2 - 0.5d0*y3
                     a2 = -0.5d0*y0 + 0.5d0*y2
                     a3 = y1
                     engcl = engcl + a0*mu*mu2 + a1*mu2 + a2*mu + a3
                  end If
               end do
            end do
            cluster(c)%poteng = engcl
            if (cluster(c)%poteng < epotcl_min) epotcl_min = cluster(c)%poteng
            if (cluster(c)%poteng > epotcl_max) epotcl_max = cluster(c)%poteng
            cluster(c)%potengperatom = cluster(c)%poteng/cluster(c)%clsize
            if (cluster(c)%potengperatom < epotperatomcl_min) epotperatomcl_min = cluster(c)%potengperatom
            if (cluster(c)%potengperatom > epotperatomcl_max) epotperatomcl_max = cluster(c)%potengperatom
         end if
      end do  
      epotcl_max = epotcl_max + potengmargin * abs(epotcl_max - epotcl_min)
      epotcl_min = epotcl_min - potengmargin * abs(epotcl_max - epotcl_min)
      epotperatomcl_max = epotperatomcl_max + potengmargin * abs(epotperatomcl_max - epotperatomcl_min)
      epotperatomcl_min = epotperatomcl_min - potengmargin * abs(epotperatomcl_max - epotperatomcl_min)
      deltapotcl=(epotcl_max - epotcl_min)/potnbins
      deltapotperatomcl=(epotperatomcl_max - epotperatomcl_min)/potnbins
      allocate(epothistomixcl(potnbins))
      allocate(epotperatomhistomixcl(potnbins))
      epothistomixcl = 0
      epotperatomhistomixcl = 0
      allocate(epotclcldata(nconf))
   end subroutine thermo_init_cluster

   subroutine potengclcl(iconf, dim, sidel, side2, maxcln, cluster)
      integer, intent(IN) :: iconf, dim, maxcln
      real, intent(IN) :: sidel(3), side2
      type(clus), dimension(maxcln), intent(inout) :: cluster
      real :: rv(3), rr2, rr, fact
      integer :: k, i, j, ind, iti, itj, ij, ir, c, d, cc, dd, jmin
      real(myprec) :: mu, mu2, xmu
      real(myprec) :: y0, y1, y2, y3, a0, a1, a2, a3
      real(double) :: engclcl

      engclcl = 0.0
      do c = 1, maxcln - 1
         do d = c + 1, maxcln
            if (cluster(c)%clsize > minclsize .and. cluster(d)%clsize > minclsize) then
               do cc = 1, cluster(c)%clsize
                  do dd = 1, cluster(d)%clsize
                     i = cluster(c)%members(cc)
                     j = cluster(d)%members(dd)
                     iti = itype(i)
                     itj = itype(j)
                     ij = thermo_fij(iti, itj, nsp)
                     rv(1:dim) = r(1:dim, i) - r(1:dim, j)
                     rv(1:dim) = rv(1:dim) - sidel(1:dim)*nint(rv(1:dim)/sidel(1:dim))
                     rr2 = Dot_product(rv(1:dim), rv(1:dim))
                     If (rr2 .Lt. rc2pot(ij)) Then
                        xmu = rr2/dr2pot
                        ir = int(xmu)
                        mu = xmu - ir
                        mu2 = mu*mu
                        y0 = pottable(ir - 1, ij)
                        y1 = pottable(ir, ij)
                        y2 = pottable(ir + 1, ij)
                        y3 = pottable(ir + 2, ij)
                        a0 = -0.5d0*y0 + 1.5d0*y1 - 1.5d0*y2 + 0.5d0*y3
                        a1 = y0 - 2.5d0*y1 + 2*y2 - 0.5d0*y3
                        a2 = -0.5d0*y0 + 0.5d0*y2
                        a3 = y1
                        engclcl = engclcl + a0*mu*mu2 + a1*mu2 + a2*mu + a3
                     end If
                  end do
               end do
            end if
         end do
      end do
      epotclcldata(iconf) = engclcl
   end subroutine potengclcl

   subroutine potengcl(iconf, dim, sidel, side2, maxcln, cluster)
      integer, intent(IN) :: iconf, dim, maxcln
      real, intent(IN) :: sidel(3), side2
      type(clus), dimension(maxcln), intent(inout) :: cluster
      real :: rv(3), rr2, rr, fact
      integer :: k, kk, i, j, ind, iti, itj, ij, ir, c, jmin
      real(myprec) :: mu, mu2, xmu
      real(myprec) :: y0, y1, y2, y3, a0, a1, a2, a3
      real(double) :: engcl

      do c = 1, maxcln
         if (cluster(c)%clsize > minclsize) then
            engcl = 0.0
            do k = 1, cluster(c)%clsize - 1
               do kk = k + 1, cluster(c)%clsize
                  i = cluster(c)%members(k)
                  j = cluster(c)%members(kk)
                  iti = itype(i)
                  itj = itype(j)
                  ij = thermo_fij(iti, itj, nsp)
                  rv(1:dim) = r(1:dim, i) - r(1:dim, j)
                  rv(1:dim) = rv(1:dim) - sidel(1:dim)*nint(rv(1:dim)/sidel(1:dim))
                  rr2 = Dot_product(rv(1:dim), rv(1:dim))
                  If (rr2 .Lt. rc2pot(ij)) Then
                     xmu = rr2/dr2pot
                     ir = int(xmu)
                     mu = xmu - ir
                     mu2 = mu*mu
                     y0 = pottable(ir - 1, ij)
                     y1 = pottable(ir, ij)
                     y2 = pottable(ir + 1, ij)
                     y3 = pottable(ir + 2, ij)
                     a0 = -0.5d0*y0 + 1.5d0*y1 - 1.5d0*y2 + 0.5d0*y3
                     a1 = y0 - 2.5d0*y1 + 2*y2 - 0.5d0*y3
                     a2 = -0.5d0*y0 + 0.5d0*y2
                     a3 = y1
                     engcl = engcl + a0*mu*mu2 + a1*mu2 + a2*mu + a3
                  end If
               end do
            end do
            cluster(c)%poteng = engcl
            ind = nint((cluster(c)%poteng-epotcl_min)/deltapotcl) + 1
            if (ind > 0 .and. ind <= potnbins) epothistomixcl(ind) = epothistomixcl(ind) + 1
            cluster(c)%potengperatom = cluster(c)%poteng/cluster(c)%clsize
            ind = nint((cluster(c)%potengperatom-epotperatomcl_min)/deltapotperatomcl) + 1
            if (ind > 0 .and. ind <= potnbins) epotperatomhistomixcl(ind) = epotperatomhistomixcl(ind) + 1
         end if
      end do
   end subroutine potengcl

   subroutine poteng(natoms, nbcuda, nthread)
      !
      ! Main call to compute potential energy and move data back and forth from device
      !
      implicit none
      integer, intent(IN) :: natoms, nbcuda, nthread
      integer :: istart, i, ind, k, l, istat
      real :: time_gpu

      istat = cudaEventRecord(startEvent, 0)
      if (use_cellp) then 
            call poteng3d_cell<<<nbcuda, nthread>>>(natoms, nsp, dr2pot)
      else
         if (ndim == 3) then
            call poteng3d<<<nbcuda, nthread>>>(natoms, nsp, dr2pot)
         else
            call poteng2d<<<nbcuda, nthread>>>(natoms, nsp, dr2pot)
         end if
      endif
      eng(:) = eng_d(:)
      time_gpu = gptime(stopEvent, startEvent)
      epot = sum(eng)/2.0
      epotperatom = epot/natoms
      tpoteng = tpoteng + time_gpu

   end subroutine poteng

   attributes(global) subroutine poteng3d(natoms, nsp, dr2pot)
      !
      ! Massively parallel potential energy calculation
      !
      integer, value, intent(IN) :: natoms, nsp
      real, value, intent(in) :: dr2pot
      integer i, j, ind, ia, fact, iti, itj, istart, ij, ir, tid
      real(myprec) :: rr2, xi, yi, zi, xd, yd, zd, mu, mu2, xmu
      real(myprec) :: y0, y1, y2, y3, a0, a1, a2, a3

      i = (blockidx%x - 1)*blockdim%x + threadidx%x
      eng_d(i) = 0.0
      if (i <= natoms) then
         iti = itype_d(i)
         xi = r_d(1, i)
         yi = r_d(2, i)
         zi = r_d(3, i)
         do j = 1, natoms
            if (i /= j) then
               itj = itype_d(j)
               ij = rdf_fij(iti, itj, nsp)
               xd = r_d(1, j) - xi
               yd = r_d(2, j) - yi
               zd = r_d(3, j) - zi
               xd = xd - sidel_d(1)*nint(xd/sidel_d(1))
               yd = yd - sidel_d(2)*nint(yd/sidel_d(2))
               zd = zd - sidel_d(3)*nint(zd/sidel_d(3))
               rr2 = xd*xd + yd*yd + zd*zd
               If (rr2 .Lt. rc2pot_d(ij)) Then
                  xmu = rr2/dr2pot
                  ir = int(xmu)
                  mu = xmu - ir
                  mu2 = mu*mu
                  y0 = pottable_d(ir - 1, ij)
                  y1 = pottable_d(ir, ij)
                  y2 = pottable_d(ir + 1, ij)
                  y3 = pottable_d(ir + 2, ij)
                  a0 = -0.5d0*y0 + 1.5d0*y1 - 1.5d0*y2 + 0.5d0*y3
                  a1 = y0 - 2.5d0*y1 + 2*y2 - 0.5d0*y3
                  a2 = -0.5d0*y0 + 0.5d0*y2
                  a3 = y1
                  eng_d(i) = eng_d(i) + a0*mu*mu2 + a1*mu2 + a2*mu + a3
               end if
            end if
         end do
      end if

   end subroutine poteng3d

attributes(global) subroutine poteng3d_cell(natoms, nsp, dr2pot)
      !
      ! Massively parallel potential energy calculation
      !
      integer, value, intent(IN) :: natoms, nsp
      real, value, intent(in) :: dr2pot
      integer i, j, ind, ia, fact, iti, itj, istart, ij, ir, tid
      real(myprec) :: rr2, xi, yi, zi, xd, yd, zd, mu, mu2, xmu
      real(myprec) :: y0, y1, y2, y3, a0, a1, a2, a3
      integer :: ix, jy, kz, icell, jcell
      i = (blockidx%x - 1)*blockdim%x + threadidx%x
      eng_d(i) = 0.0
      if (i <= natoms) then
         iti = itype_d(i)
         xi = r_d(1, i)
         yi = r_d(2, i)
         zi = r_d(3, i)
         ix = int(xi/cellxpd)
         jy = int(yi/cellypd)
         kz = int(zi/cellzpd)
         icell = (ix*maxjpd + jy)*maxkpd + kz
            !
            ! Loop over neighbouring cells
         do jcell = 1, nnpd
            j = headpd(neighpd(icell, jcell))
            do while (j .ne. 0)
               if (i /= j) then
                  itj = itype_d(j)
                  ij = rdf_fij(iti, itj, nsp)
                  xd = r_d(1, j) - xi
                  yd = r_d(2, j) - yi
                  zd = r_d(3, j) - zi
                  xd = xd - sidel_d(1)*nint(xd/sidel_d(1))
                  yd = yd - sidel_d(2)*nint(yd/sidel_d(2))
                  zd = zd - sidel_d(3)*nint(zd/sidel_d(3))
                  rr2 = xd*xd + yd*yd + zd*zd
                  If (rr2 .Lt. rc2pot_d(ij)) Then
                     xmu = rr2/dr2pot
                     ir = int(xmu)
                     mu = xmu - ir
                     mu2 = mu*mu
                     y0 = pottable_d(ir - 1, ij)
                     y1 = pottable_d(ir, ij)
                     y2 = pottable_d(ir + 1, ij)
                     y3 = pottable_d(ir + 2, ij)
                     a0 = -0.5d0*y0 + 1.5d0*y1 - 1.5d0*y2 + 0.5d0*y3
                     a1 = y0 - 2.5d0*y1 + 2*y2 - 0.5d0*y3
                     a2 = -0.5d0*y0 + 0.5d0*y2
                     a3 = y1
                     eng_d(i) = eng_d(i) + a0*mu*mu2 + a1*mu2 + a2*mu + a3
                  end if
               end if
               j = listapd(j)
            end do
         end do
      end if

   end subroutine poteng3d_cell

   attributes(global) subroutine poteng2d(natoms, nsp, dr2pot)
      !
      ! Massively parallel potential energy calculation
      !
      integer, value, intent(IN) :: natoms, nsp
      real, value, intent(in) :: dr2pot
      integer i, j, ind, ia, fact, iti, itj, istart, ij, ir
      real(myprec) :: rr2, xi, yi, xd, yd, mu, mu2, xmu
      real(myprec) :: y0, y1, y2, y3, a0, a1, a2, a3

      i = (blockidx%x - 1)*blockdim%x + threadidx%x
      eng_d(i) = 0.0
      if (i <= natoms) then
         iti = itype_d(i)
         xi = r_d(1, i)
         yi = r_d(2, i)
         do j = 1, natoms
            if (i /= j) then
               itj = itype_d(j)
               ij = rdf_fij(iti, itj, nsp)
               xd = r_d(1, j) - xi
               yd = r_d(2, j) - yi
               xd = xd - sidel_d(1)*nint(xd/sidel_d(1))
               yd = yd - sidel_d(2)*nint(yd/sidel_d(2))
               rr2 = xd*xd + yd*yd
               If (rr2 .Lt. rc2pot_d(ij)) Then
                  xmu = rr2/dr2pot
                  ir = int(xmu)
                  mu = xmu - ir
                  mu2 = mu*mu
                  y0 = pottable_d(ir - 1, ij)
                  y1 = pottable_d(ir, ij)
                  y2 = pottable_d(ir + 1, ij)
                  y3 = pottable_d(ir + 2, ij)
                  a0 = -0.5d0*y0 + 1.5d0*y1 - 1.5d0*y2 + 0.5d0*y3
                  a1 = y0 - 2.5d0*y1 + 2*y2 - 0.5d0*y3
                  a2 = -0.5d0*y0 + 0.5d0*y2
                  a3 = y1
                  eng_d(i) = eng_d(i) + a0*mu*mu2 + a1*mu2 + a2*mu + a3
               end if
            end if
         end do
      end if

   end subroutine poteng2d

   subroutine thermo_clear()
      deallocate (rc2pot)
      deallocate (rc2pot_d)
      deallocate (pottable)
      deallocate (pottable_d)
      deallocate (rr2table)
      deallocate (eng)
      deallocate (eng_d)
      deallocate (epothistomixcl)
      deallocate (epotperatomhistomixcl)
      deallocate (epotclcldata)
   end subroutine thermo_clear

   attributes(device) integer function rdf_fij(i, j, nsp)
      implicit none
      integer, value :: i, j, nsp
      !
      ! this function maps the indices (i,j) of a symmetric matrix A(i,j) onto the single index k
      ! of a vector
      !
      if (i <= j) then
         rdf_fij = (i - 1)*(nsp - 1) - (i - 1)*(i - 2)/2 + j
      else
         rdf_fij = (j - 1)*(nsp - 1) - (j - 1)*(j - 2)/2 + i
      end if
   end function rdf_fij

   integer function thermo_fij(i, j, nsp)
      implicit none
      integer, value :: i, j, nsp
      !
      ! this function maps the indices (i,j) of a symmetric matrix A(i,j) onto the single index k
      ! of a vector
      !
      if (i <= j) then
         thermo_fij = (i - 1)*(nsp - 1) - (i - 1)*(i - 2)/2 + j
      else
         thermo_fij = (j - 1)*(nsp - 1) - (j - 1)*(j - 2)/2 + i
      end if
   end function thermo_fij

end module mod_thermo
